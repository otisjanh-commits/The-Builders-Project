#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <memory>
#include <ctime>
#include <iomanip>
#include <sstream>
#include <algorithm>
#include <fstream>
#include <random>
#include <openssl/sha.h>
#include <bcrypt.h>
#include <sqlite3.h>
#include <curl/curl.h>
#include <nlohmann/json.hpp>

using namespace std;
using json = nlohmann::json;

// Constants
const double UK_VAT_RATE = 0.20;
const string CURRENT_YEAR = "2025";

// Utility Functions
string getCurrentDateTime() {
    time_t now = time(0);
    tm* ltm = localtime(&now);
    char buffer[80];
    strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", ltm);
    return string(buffer);
}

string generateUUID() {
    random_device rd;
    mt19937 gen(rd());
    uniform_int_distribution<> dis(0, 15);
    uniform_int_distribution<> dis2(8, 11);
    
    stringstream ss;
    ss << hex;
    for (int i = 0; i < 8; i++) ss << dis(gen);
    ss << "-";
    for (int i = 0; i < 4; i++) ss << dis(gen);
    ss << "-4";
    for (int i = 0; i < 3; i++) ss << dis(gen);
    ss << "-";
    ss << dis2(gen);
    for (int i = 0; i < 3; i++) ss << dis(gen);
    ss << "-";
    for (int i = 0; i < 12; i++) ss << dis(gen);
    
    return ss.str();
}

// Encryption and Security Handler
class SecurityManager {
private:
    string encryptionKey;
    
public:
    SecurityManager(const string& key) : encryptionKey(key) {}
    
    string hashPassword(const string& password) {
        char hashedPassword[100];
        bcrypt_hashpw(password.c_str(), bcrypt_gensalt(12), hashedPassword);
        return string(hashedPassword);
    }
    
    bool verifyPassword(const string& password, const string& hash) {
        return bcrypt_checkpw(password.c_str(), hash.c_str()) == 0;
    }
    
    string encryptData(const string& data) {
        // Simple XOR encryption for demonstration (use AES in production)
        string encrypted = data;
        for (size_t i = 0; i < data.size(); i++) {
            encrypted[i] = data[i] ^ encryptionKey[i % encryptionKey.size()];
        }
        return encrypted;
    }
    
    string decryptData(const string& data) {
        return encryptData(data); // XOR is symmetric
    }
    
    string generateSessionToken() {
        return generateUUID();
    }
};

// Database Manager
class DatabaseManager {
private:
    sqlite3* db;
    string dbPath;
    
public:
    DatabaseManager(const string& path) : dbPath(path) {
        if (sqlite3_open(dbPath.c_str(), &db) != SQLITE_OK) {
            cerr << "Can't open database: " << sqlite3_errmsg(db) << endl;
        } else {
            initializeDatabase();
        }
    }
    
    ~DatabaseManager() {
        sqlite3_close(db);
    }
    
    void initializeDatabase() {
        // Users table
        const char* usersSql = R"(
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                uuid TEXT UNIQUE NOT NULL,
                email TEXT UNIQUE NOT NULL,
                password_hash TEXT NOT NULL,
                user_type TEXT NOT NULL,
                first_name TEXT NOT NULL,
                last_name TEXT NOT NULL,
                company_name TEXT,
                company_reg_number TEXT,
                utr_number TEXT,
                vat_number TEXT,
                cis_status TEXT,
                bank_account_details TEXT,
                address TEXT,
                phone_number TEXT,
                subscription_plan TEXT DEFAULT 'free',
                subscription_status TEXT DEFAULT 'inactive',
                subscription_expiry DATE,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            );
        )";
        
        // Projects table
        const char* projectsSql = R"(
            CREATE TABLE IF NOT EXISTS projects (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                uuid TEXT UNIQUE NOT NULL,
                user_id INTEGER NOT NULL,
                name TEXT NOT NULL,
                description TEXT,
                client_name TEXT,
                client_address TEXT,
                client_email TEXT,
                client_phone TEXT,
                site_address TEXT,
                start_date DATE,
                end_date DATE,
                budget REAL,
                status TEXT DEFAULT 'planning',
                progress INTEGER DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY(user_id) REFERENCES users(id)
            );
        )";
        
        // Material categories table
        const char* materialCategoriesSql = R"(
            CREATE TABLE IF NOT EXISTS material_categories (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                description TEXT,
                parent_id INTEGER DEFAULT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY(parent_id) REFERENCES material_categories(id)
            );
        )";
        
        // Materials table
        const char* materialsSql = R"(
            CREATE TABLE IF NOT EXISTS materials (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                uuid TEXT UNIQUE NOT NULL,
                category_id INTEGER NOT NULL,
                name TEXT NOT NULL,
                description TEXT,
                unit TEXT NOT NULL,
                base_price REAL NOT NULL,
                vat_rate REAL DEFAULT 0.2,
                supplier TEXT,
                supplier_code TEXT,
                brand TEXT,
                weight_kg REAL,
                dimensions TEXT,
                material_type TEXT,
                color TEXT,
                certification TEXT,
                sustainability_rating INTEGER,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY(category_id) REFERENCES material_categories(id)
            );
        )";
        
        // Project materials table
        const char* projectMaterialsSql = R"(
            CREATE TABLE IF NOT EXISTS project_materials (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                project_id INTEGER NOT NULL,
                material_id INTEGER NOT NULL,
                quantity REAL NOT NULL,
                unit_price REAL NOT NULL,
                vat_included INTEGER DEFAULT 1,
                stage TEXT DEFAULT 'planning',
                status TEXT DEFAULT 'pending',
                delivery_date DATE,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY(project_id) REFERENCES projects(id),
                FOREIGN KEY(material_id) REFERENCES materials(id)
            );
        )";
        
        // Trade categories table
        const char* tradeCategoriesSql = R"(
            CREATE TABLE IF NOT EXISTS trade_categories (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                description TEXT,
                parent_id INTEGER DEFAULT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY(parent_id) REFERENCES trade_categories(id)
            );
        )";
        
        // Labor rates table
        const char* laborRatesSql = R"(
            CREATE TABLE IF NOT EXISTS labor_rates (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                trade_id INTEGER NOT NULL,
                region TEXT NOT NULL,
                level TEXT NOT NULL,
                rate REAL NOT NULL,
                overtime_rate REAL,
                weekend_rate REAL,
                holiday_rate REAL,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY(trade_id) REFERENCES trade_categories(id)
            );
        )";
        
        // Project labor table
        const char* projectLaborSql = R"(
            CREATE TABLE IF NOT EXISTS project_labor (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                project_id INTEGER NOT NULL,
                trade_id INTEGER NOT NULL,
                hours REAL NOT NULL,
                rate REAL NOT NULL,
                level TEXT NOT NULL,
                worker_name TEXT,
                worker_id TEXT,
                stage TEXT DEFAULT 'planning',
                status TEXT DEFAULT 'pending',
                start_date DATE,
                end_date DATE,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY(project_id) REFERENCES projects(id),
                FOREIGN KEY(trade_id) REFERENCES trade_categories(id)
            );
        )";
        
        // Equipment table
        const char* equipmentSql = R"(
            CREATE TABLE IF NOT EXISTS equipment (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                description TEXT,
                category TEXT NOT NULL,
                daily_rate REAL NOT NULL,
                weekly_rate REAL,
                monthly_rate REAL,
                operator_cost REAL,
                fuel_cost REAL,
                maintenance_cost REAL,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            );
        )";
        
        // Project equipment table
        const char* projectEquipmentSql = R"(
            CREATE TABLE IF NOT EXISTS project_equipment (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                project_id INTEGER NOT NULL,
                equipment_id INTEGER NOT NULL,
                quantity INTEGER NOT NULL,
                days INTEGER NOT NULL,
                daily_rate REAL NOT NULL,
                operator_cost REAL,
                fuel_cost REAL,
                stage TEXT DEFAULT 'planning',
                status TEXT DEFAULT 'pending',
                start_date DATE,
                end_date DATE,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY(project_id) REFERENCES projects(id),
                FOREIGN KEY(equipment_id) REFERENCES equipment(id)
            );
        )";
        
        // Invoices table
        const char* invoicesSql = R"(
            CREATE TABLE IF NOT EXISTS invoices (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                uuid TEXT UNIQUE NOT NULL,
                project_id INTEGER NOT NULL,
                invoice_number TEXT UNIQUE NOT NULL,
                issue_date DATE,
                due_date DATE,
                status TEXT DEFAULT 'draft',
                total_amount REAL,
                vat_amount REAL,
                amount_paid REAL DEFAULT 0,
                payment_date DATE,
                payment_method TEXT,
                notes TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY(project_id) REFERENCES projects(id)
            );
        )";
        
        // Invoice items table
        const char* invoiceItemsSql = R"(
            CREATE TABLE IF NOT EXISTS invoice_items (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                invoice_id INTEGER NOT NULL,
                item_type TEXT NOT NULL,
                item_description TEXT NOT NULL,
                quantity REAL NOT NULL,
                unit_price REAL NOT NULL,
                vat_rate REAL NOT NULL,
                total_amount REAL NOT NULL,
                FOREIGN KEY(invoice_id) REFERENCES invoices(id)
            );
        )";
        
        // Project stages table
        const char* projectStagesSql = R"(
            CREATE TABLE IF NOT EXISTS project_stages (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                project_id INTEGER NOT NULL,
                name TEXT NOT NULL,
                description TEXT,
                sequence INTEGER NOT NULL,
                planned_start DATE,
                planned_end DATE,
                actual_start DATE,
                actual_end DATE,
                status TEXT DEFAULT 'pending',
                progress INTEGER DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY(project_id) REFERENCES projects(id)
            );
        )";
        
        // Project documents table
        const char* projectDocumentsSql = R"(
            CREATE TABLE IF NOT EXISTS project_documents (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                project_id INTEGER NOT NULL,
                name TEXT NOT NULL,
                description TEXT,
                file_path TEXT NOT NULL,
                document_type TEXT NOT NULL,
                uploaded_by INTEGER NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY(project_id) REFERENCES projects(id),
                FOREIGN KEY(uploaded_by) REFERENCES users(id)
            );
        )";
        
        // Project photos table
        const char* projectPhotosSql = R"(
            CREATE TABLE IF NOT EXISTS project_photos (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                project_id INTEGER NOT NULL,
                stage_id INTEGER,
                description TEXT,
                file_path TEXT NOT NULL,
                uploaded_by INTEGER NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY(project_id) REFERENCES projects(id),
                FOREIGN KEY(stage_id) REFERENCES project_stages(id),
                FOREIGN KEY(uploaded_by) REFERENCES users(id)
            );
        )";
        
        // Project tasks table
        const char* projectTasksSql = R"(
            CREATE TABLE IF NOT EXISTS project_tasks (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                project_id INTEGER NOT NULL,
                stage_id INTEGER,
                name TEXT NOT NULL,
                description TEXT,
                assigned_to INTEGER,
                priority TEXT DEFAULT 'medium',
                planned_start DATE,
                planned_end DATE,
                actual_start DATE,
                actual_end DATE,
                status TEXT DEFAULT 'pending',
                progress INTEGER DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY(project_id) REFERENCES projects(id),
                FOREIGN KEY(stage_id) REFERENCES project_stages(id),
                FOREIGN KEY(assigned_to) REFERENCES users(id)
            );
        )";
        
        // AI recommendations table
        const char* aiRecommendationsSql = R"(
            CREATE TABLE IF NOT EXISTS ai_recommendations (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                project_id INTEGER NOT NULL,
                category TEXT NOT NULL,
                recommendation TEXT NOT NULL,
                priority TEXT DEFAULT 'medium',
                status TEXT DEFAULT 'pending',
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY(project_id) REFERENCES projects(id)
            );
        )";
        
        // Execute all table creation queries
        executeQuery(usersSql);
        executeQuery(projectsSql);
        executeQuery(materialCategoriesSql);
        executeQuery(materialsSql);
        executeQuery(projectMaterialsSql);
        executeQuery(tradeCategoriesSql);
        executeQuery(laborRatesSql);
        executeQuery(projectLaborSql);
        executeQuery(equipmentSql);
        executeQuery(projectEquipmentSql);
        executeQuery(invoicesSql);
        executeQuery(invoiceItemsSql);
        executeQuery(projectStagesSql);
        executeQuery(projectDocumentsSql);
        executeQuery(projectPhotosSql);
        executeQuery(projectTasksSql);
        executeQuery(aiRecommendationsSql);
        
        // Insert sample data
        insertSampleData();
    }
    
    void executeQuery(const char* sql) {
        char* errMsg = nullptr;
        if (sqlite3_exec(db, sql, nullptr, nullptr, &errMsg) != SQLITE_OK) {
            cerr << "SQL error: " << errMsg << endl;
            sqlite3_free(errMsg);
        }
    }
    
    bool executeParamQuery(const string& sql, const vector<string>& params) {
        sqlite3_stmt* stmt;
        if (sqlite3_prepare_v2(db, sql.c_str(), -1, &stmt, nullptr) != SQLITE_OK) {
            return false;
        }
        
        for (int i = 0; i < params.size(); i++) {
            sqlite3_bind_text(stmt, i + 1, params[i].c_str(), -1, SQLITE_STATIC);
        }
        
        bool result = sqlite3_step(stmt) == SQLITE_DONE;
        sqlite3_finalize(stmt);
        return result;
    }
    
    vector<map<string, string>> executeSelectQuery(const string& sql, const vector<string>& params = {}) {
        sqlite3_stmt* stmt;
        vector<map<string, string>> results;
        
        if (sqlite3_prepare_v2(db, sql.c_str(), -1, &stmt, nullptr) != SQLITE_OK) {
            return results;
        }
        
        for (int i = 0; i < params.size(); i++) {
            sqlite3_bind_text(stmt, i + 1, params[i].c_str(), -1, SQLITE_STATIC);
        }
        
        while (sqlite3_step(stmt) == SQLITE_ROW) {
            map<string, string> row;
            int colCount = sqlite3_column_count(stmt);
            
            for (int i = 0; i < colCount; i++) {
                string colName = sqlite3_column_name(stmt, i);
                const unsigned char* value = sqlite3_column_text(stmt, i);
                if (value) {
                    row[colName] = string(reinterpret_cast<const char*>(value));
                } else {
                    row[colName] = "";
                }
            }
            
            results.push_back(row);
        }
        
        sqlite3_finalize(stmt);
        return results;
    }
    
    void insertSampleData() {
        // Insert material categories
        const char* materialCategoriesData = R"(
            INSERT OR IGNORE INTO material_categories (name, description, parent_id) VALUES
            ('Masonry', 'Bricks, blocks, mortar, and related materials', NULL),
            ('Timber', 'Wood and wood products', NULL),
            ('Insulation', 'Thermal and acoustic insulation materials', NULL),
            ('Roofing', 'Roofing materials and accessories', NULL),
            ('Plumbing', 'Pipes, fittings, and plumbing accessories', NULL),
            ('Electrical', 'Wiring, cables, and electrical components', NULL),
            ('Plastering', 'Plaster, plasterboard, and finishing materials', NULL),
            ('Flooring', 'Flooring materials and accessories', NULL),
            ('Painting & Decorating', 'Paints, primers, and decorating supplies', NULL),
            ('Landscaping', 'Materials for outdoor and landscaping projects', NULL),
            ('Ironmongery', 'Hardware and metal fittings', NULL),
            ('Health & Safety', 'Safety equipment and supplies', NULL),
            ('Tools & Equipment', 'Tools and construction equipment', NULL),
            ('Windows & Doors', 'Windows, doors, and related components', NULL),
            ('Concrete & Aggregates', 'Concrete, cement, and aggregate materials', NULL),
            ('Adhesives & Sealants', 'Glues, adhesives, and sealing compounds', NULL),
            ('Bricks', 'Various types of bricks', 1),
            ('Blocks', 'Concrete and other blocks', 1),
            ('Mortar', 'Mortar mixes and additives', 1),
            ('Softwood', 'Softwood timber products', 2),
            ('Hardwood', 'Hardwood timber products', 2),
            ('Sheet Materials', 'Plywood, OSB, MDF, etc.', 2),
            ('Cavity Insulation', 'Insulation for cavity walls', 3),
            ('Loft Insulation', 'Insulation for loft spaces', 3),
            ('Solid Wall Insulation', 'Insulation for solid walls', 3),
            ('Roof Tiles', 'Various types of roof tiles', 4),
            ('Slates', 'Roofing slates', 4),
            ('Roofing Felt', 'Roofing underlay and felts', 4),
            ('Guttering', 'Rainwater drainage systems', 4),
            ('Copper Pipes', 'Copper piping and fittings', 5),
            ('Plastic Pipes', 'Plastic piping and fittings', 5),
            ('Fittings', 'Pipe fittings and connectors', 5),
            ('Cable', 'Electrical cables and wires', 6),
            ('Consumer Units', 'Fuse boxes and distribution boards', 6),
            ('Sockets & Switches', 'Electrical outlets and switches', 6),
            ('Lighting', 'Light fixtures and accessories', 6),
            ('Cable Management', 'Trunking, conduits, and clips', 6),
            ('Plasterboard', 'Wall and ceiling boards', 7),
            ('Plaster', 'Plaster and finishing compounds', 7),
            ('Beading', 'Plaster beads and accessories', 7),
            ('Floorboards', 'Wooden floorboarding', 8),
            ('Screed', 'Floor screeding materials', 8),
            ('Tiles', 'Floor tiles and accessories', 8),
            ('Underlay', 'Floor underlay materials', 8),
            ('Emulsion Paint', 'Wall emulsion paints', 9),
            ('Gloss Paint', 'Wood and metal gloss paints', 9),
            ('Primer', 'Primers and undercoats', 9),
            ('Wallpaper', 'Wall coverings and pastes', 9),
            ('Paving', 'Paving slabs and stones', 10),
            ('Decking', 'Decking materials', 10),
            ('Fencing', 'Fencing materials and posts', 10),
            ('Turf & Soil', 'Turf, soil, and growing materials', 10),
            ('Screws & Fixings', 'Screws, nails, and mechanical fixings', 11),
            ('Locks & Latches', 'Door and window hardware', 11),
            ('Hinges', 'Various types of hinges', 11),
            ('PPE', 'Personal protective equipment', 12),
            ('Signage', 'Safety signs and markers', 12),
            ('Barriers', 'Safety barriers and fencing', 12),
            ('Hand Tools', 'Manual tools', 13),
            ('Power Tools', 'Electric and battery tools', 13),
            ('Lifting Equipment', 'Hoists, jacks, and lifting gear', 13),
            ('UPVC Windows', 'UPVC window systems', 14),
            ('Timber Windows', 'Wooden window systems', 14),
            ('Doors', 'Internal and external doors', 14),
            ('Concrete', 'Ready-mix and bagged concrete', 15),
            ('Aggregates', 'Sand, gravel, and stones', 15),
            ('Cement', 'Cement and cement additives', 15),
            ('Adhesives', 'Construction adhesives', 16),
            ('Sealants', 'Sealants and caulking', 16);
        )";
        
        // Insert sample materials
        const char* materialsData = R"(
            INSERT OR IGNORE INTO materials (uuid, category_id, name, description, unit, base_price, supplier, brand) VALUES
            ('brick-common-001', 17, 'Common Bricks', 'Standard facing bricks', 'per 1000', 485.00, 'BuildMerchant', 'Wienerberger'),
            ('brick-engineering-001', 17, 'Engineering Bricks', 'Class B engineering bricks', 'per 1000', 710.00, 'BuildMerchant', 'Wienerberger'),
            ('block-concrete-001', 18, 'Concrete Blocks', '100mm dense concrete blocks', 'each', 1.85, 'BuildMerchant', 'Thermalite'),
            ('block-aac-001', 18, 'AAC Blocks', 'Aircrete autoclaved aerated concrete blocks', 'each', 2.45, 'BuildMerchant', 'Thermalite'),
            ('mortar-general-001', 19, 'General Purpose Mortar', 'Ready-mix mortar', '25kg bag', 8.20, 'BuildMerchant', 'Tarmac'),
            ('timber-c16-001', 20, 'C16 Graded Timber', 'Structural softwood timber', 'm³', 735.00, 'TimberWorld', 'B&K'),
            ('timber-hardwood-001', 21, 'Oak Hardwood', 'European oak hardwood', 'm³', 1250.00, 'TimberWorld', 'B&K'),
            ('plywood-001', 22, 'Structural Plywood', '18mm structural plywood', 'sheet', 28.50, 'TimberWorld', 'Medite'),
            ('osb-001', 22, 'OSB Board', '18mm oriented strand board', 'sheet', 22.75, 'TimberWorld', 'Norbord'),
            ('insulation-cavity-001', 23, 'Cavity Wall Insulation', 'PIR board insulation', 'm²', 14.50, 'InsulateUK', 'Celotex'),
            ('insulation-loft-001', 24, 'Loft Insulation', 'Glass wool loft insulation', 'm²', 12.25, 'InsulateUK', 'Knauf'),
            ('insulation-ewi-001', 25, 'External Wall Insulation', 'EPS external wall insulation', 'm²', 18.75, 'InsulateUK', 'Sto'),
            ('tile-concrete-001', 26, 'Concrete Roof Tiles', 'Interlocking concrete tiles', 'm²', 35.20, 'RoofingSupplies', 'Redland'),
            ('slate-natural-001', 27, 'Natural Slate', 'Spanish natural slate', 'm²', 45.80, 'RoofingSupplies', 'Cupa'),
            ('felt-roofing-001', 28, 'Roofing Felt', 'Type 1F roofing underlay', 'roll', 65.00, 'RoofingSupplies', 'IKO'),
            ('guttering-upvc-001', 29, 'UPVC Guttering', '112mm half-round gutter system', 'm', 8.50, 'RoofingSupplies', 'Floplast'),
            ('pipe-copper-001', 30, 'Copper Pipe', '15mm copper pipe', 'm', 20.25, 'PlumbingDirect', 'Yorkshire'),
            ('pipe-plastic-001', 31, 'Plastic Pipe', '15mm MDPE pipe', 'm', 12.50, 'PlumbingDirect', 'Polypipe'),
            ('fitting-compression-001', 32, 'Compression Fitting', '15mm compression elbow', 'each', 2.75, 'PlumbingDirect', 'Yorkshire'),
            ('cable-twin-001', 33, 'Twin & Earth Cable', '2.5mm twin and earth', 'm', 0.85, 'ElectricalWorld', 'British General'),
            ('consumer-unit-001', 34, 'Consumer Unit', '10-way dual RCD consumer unit', 'each', 120.00, 'ElectricalWorld', 'Hager'),
            ('socket-double-001', 35, 'Double Socket', 'White double socket', 'each', 5.25, 'ElectricalWorld', 'MK'),
            ('lighting-batten-001', 36, 'LED Batten Light', '5ft LED batten light', 'each', 25.00, 'ElectricalWorld', 'Scolmore'),
            ('trunking-001', 37, 'PVC Trunking', '25mm x 16mm PVC trunking', 'm', 1.20, 'ElectricalWorld', 'Marshall-Tufflex'),
            ('cable-clips-001', 37, 'Cable Clips', 'Nylon cable clips pack of 100', 'pack', 3.50, 'ElectricalWorld', 'Unicorn'),
            ('plasterboard-001', 38, 'Plasterboard', '12.5mm standard plasterboard', 'm²', 7.35, 'BuildMerchant', 'British Gypsum'),
            ('plaster-multi-001', 39, 'Multi-Finish Plaster', 'Thistle multi-finish plaster', '25kg bag', 9.80, 'BuildMerchant', 'British Gypsum'),
            ('bead-angle-001', 40, 'Angle Bead', '3mm galvanized angle bead', 'm', 1.25, 'BuildMerchant', 'British Gypsum'),
            ('floorboard-001', 41, 'Floorboards', '18mm T&G chipboard flooring', 'm²', 15.50, 'BuildMerchant', 'Egger'),
            ('screed-001', 42, 'Floor Screed', 'Self-leveling floor screed', '25kg bag', 8.25, 'BuildMerchant', 'Tarmac'),
            ('tile-ceramic-001', 43, 'Ceramic Floor Tiles', '300x300mm ceramic floor tiles', 'm²', 32.00, 'TileWorld', 'Porcelanosa'),
            ('underlay-001', 44, 'Floor Underlay', '2mm foam floor underlay', 'm²', 3.50, 'BuildMerchant', 'Duralay'),
            ('paint-emulsion-001', 45, 'Emulsion Paint', 'White matt emulsion', '5L', 28.50, 'DecoratingDirect', 'Dulux'),
            ('paint-gloss-001', 46, 'Gloss Paint', 'White gloss paint', '2.5L', 32.00, 'DecoratingDirect', 'Dulux'),
            ('primer-001', 47, 'Multi-Surface Primer', 'All-purpose primer', '5L', 25.00, 'DecoratingDirect', 'Zinsser'),
            ('wallpaper-001', 48, 'Wallpaper', 'Textured wallpaper', 'roll', 15.00, 'DecoratingDirect', 'Graham & Brown'),
            ('paving-001', 49, 'Paving Slabs', '600x600mm concrete paving slabs', 'm²', 22.00, 'LandscapeWorld', 'Marshalls'),
            ('decking-001', 50, 'Decking Boards', ' treated decking boards', 'm', 18.50, 'LandscapeWorld', 'Travis Perkins'),
            ('fencing-001', 51, 'Closeboard Fencing', '1.8m closeboard fence panel', 'panel', 35.00, 'LandscapeWorld', 'Jacksons'),
            ('turf-001', 52, 'Turf', 'Quality lawn turf', 'm²', 5.50, 'LandscapeWorld', 'Rolawn'),
            ('screws-001', 53, 'Wood Screws', '4.0x50mm countersunk screws', 'pack of 200', 8.00, 'IronmongeryDirect', 'Spax'),
            ('lock-001', 54, 'Mortice Lock', '5-lever mortice deadlock', 'each', 25.00, 'IronmongeryDirect', 'Yale'),
            ('hinge-001', 55, 'Butt Hinges', '75mm steel butt hinges', 'pair', 3.50, 'IronmongeryDirect', 'Hettich'),
            ('ppe-helmet-001', 56, 'Safety Helmet', 'Industrial safety helmet', 'each', 12.00, 'SafetySupply', 'JSP'),
            ('signage-001', 57, 'Safety Sign', 'Hard hat area sign', 'each', 8.50, 'SafetySupply', 'Seton'),
            ('barrier-001', 58, 'Safety Barrier', '2m plastic safety barrier', 'each', 45.00, 'SafetySupply', 'Brady'),
            ('hammer-001', 59, 'Claw Hammer', '20oz claw hammer', 'each', 15.00, 'ToolStation', 'Stanley'),
            ('drill-001', 60, 'Combi Drill', '18V cordless combi drill', 'each', 120.00, 'ToolStation', 'DeWalt'),
            ('hoist-001', 61, 'Material Hoist', '500kg electric material hoist', 'each', 1250.00, 'ToolStation', 'Zarges'),
            ('window-upvc-001', 62, 'UPVC Window', '1200x1200mm white UPVC window', 'each', 350.00, 'WindowWorld', 'Eurocell'),
            ('window-timber-001', 63, 'Timber Window', '1200x1200mm softwood window', 'each', 420.00, 'WindowWorld', 'Jeld-Wen'),
            ('door-internal-001', 64, 'Internal Door', '1981x762mm white internal door', 'each', 85.00, 'DoorWorld', 'Magnet'),
            ('concrete-001', 65, 'Ready-Mix Concrete', 'C25P concrete', 'm³', 95.00, 'AggregateSupply', 'Tarmac'),
            ('aggregate-001', 66, 'Sharp Sand', 'Building sharp sand', 'tonne', 48.50, 'AggregateSupply', 'Tarmac'),
            ('cement-001', 67, 'Portland Cement', 'CEM I 52.5N cement', '25kg bag', 8.50, 'AggregateSupply', 'Tarmac'),
            ('adhesive-tile-001', 68, 'Tile Adhesive', 'Flexible tile adhesive', '20kg bag', 15.00, 'BuildMerchant', 'BAL'),
            ('sealant-silicone-001', 69, 'Silicone Sealant', 'Sanitary silicone sealant', 'tube', 4.50, 'BuildMerchant', 'Dow');
        )";
        
        // Insert trade categories
        const char* tradeCategoriesData = R"(
            INSERT OR IGNORE INTO trade_categories (name, description, parent_id) VALUES
            ('Groundworks', 'Site preparation and foundations', NULL),
            ('Bricklaying', 'Brick and block work', NULL),
            ('Carpentry', 'Woodwork and structural timber', NULL),
            ('Plumbing', 'Pipework and sanitary installations', NULL),
            ('Electrical', 'Wiring and electrical installations', NULL),
            ('Plastering', 'Wall and ceiling finishing', NULL),
            ('Roofing', 'Roof construction and finishing', NULL),
            ('Flooring', 'Floor installation and finishing', NULL),
            ('Painting & Decorating', 'Surface finishing and decoration', NULL),
            ('Glazing', 'Window and glass installation', NULL),
            ('Scaffolding', 'Temporary structures and access', NULL),
            ('Demolition', 'Structure removal and site clearance', NULL),
            ('Landscaping', 'External works and garden construction', NULL),
            ('HVAC', 'Heating, ventilation and air conditioning', NULL),
            ('Steelwork', 'Structural steel fabrication and erection', NULL),
            ('Facades', 'External wall systems and cladding', NULL),
            ('Fire Protection', 'Fire stopping and protection systems', NULL),
            ('Site Management', 'Project coordination and supervision', NULL),
            ('Laborer', 'General site assistance and support', NULL),
            ('Plant Operator', 'Machinery operation', NULL),
            ('Excavation', 'Ground excavation and preparation', 1),
            ('Foundations', 'Foundation construction', 1),
            ('Drainage', 'Below-ground drainage systems', 1),
            ('Brickwork', 'Brick laying and construction', 2),
            ('Blockwork', 'Block laying and construction', 2),
            ('Stonework', 'Natural stone construction', 2),
            ('First Fix', 'Initial structural carpentry', 3),
            ('Second Fix', 'Finish carpentry and installation', 3),
            ('Joinery', 'Custom woodwork and furniture', 3),
            ('Water Supply', 'Potable water systems', 4),
            ('Drainage', 'Above-ground drainage systems', 4),
            ('Heating', 'Central heating systems', 4),
            ('Power', 'Electrical power distribution', 5),
            ('Lighting', 'Lighting systems installation', 5),
            ('Data', 'Data and communication systems', 5),
            ('Security', 'Security and alarm systems', 5),
            ('Plastering', 'Wall and ceiling plastering', 6),
            ('Drylining', 'Plasterboard installation', 6),
            ('Rendering', 'External wall rendering', 6),
            ('Tiling', 'Roof tiling and slating', 7),
            ('Flat Roofing', 'Flat roof systems', 7),
            ('Flashings', 'Roof flashings and details', 7),
            ('Wood Flooring', 'Timber floor installation', 8),
            ('Tile Flooring', 'Tile floor installation', 8),
            ('Resin Flooring', 'Resin floor systems', 8),
            ('Painting', 'Surface painting', 9),
            ('Wallpapering', 'Wall covering installation', 9),
            ('Decorating', 'Finish decoration', 9),
            ('Window Installation', 'Window fitting and glazing', 10),
            ('Glass Installation', 'Specialist glass work', 10),
            ('Scaffold Erection', 'Scaffolding assembly', 11),
            ('Scaffold Dismantling', 'Scaffolding removal', 11),
            ('Structural Demolition', 'Building demolition', 12),
            ('Strip Out', 'Internal removal works', 12),
            ('Soft Landscaping', 'Planting and vegetation', 13),
            ('Hard Landscaping', 'Paving and structures', 13),
            ('Heating Systems', 'Heating installation', 14),
            ('Ventilation', 'Ventilation systems', 14),
            ('Steel Erection', 'Structural steel installation', 15),
            ('Steel Fabrication', 'Steel component fabrication', 15),
            ('Cladding', 'External cladding systems', 16),
            ('Curtain Walling', 'Structural glazing systems', 16),
            ('Fire Stopping', 'Compartmentation and sealing', 17),
            ('Fire Alarm', 'Fire detection systems', 17),
            ('Site Supervision', 'Site management and coordination', 18),
            ('Planning', 'Project planning and scheduling', 18),
            ('General Labor', 'General site assistance', 19),
            ('Cleaner', 'Site cleaning and waste management', 19),
            ('Crane Operator', 'Crane operation', 20),
            ('Digger Operator', 'Excavator operation', 20);
        )";
        
        // Insert labor rates
        const char* laborRatesData = R"(
            INSERT OR IGNORE INTO labor_rates (trade_id, region, level, rate, overtime_rate, weekend_rate, holiday_rate) VALUES
            (21, 'London', 'Standard', 22.50, 33.75, 45.00, 56.25),
            (21, 'London', 'Advanced', 26.00, 39.00, 52.00, 65.00),
            (21, 'South East', 'Standard', 20.00, 30.00, 40.00, 50.00),
            (21, 'South East', 'Advanced', 23.00, 34.50, 46.00, 57.50),
            (21, 'National', 'Standard', 18.50, 27.75, 37.00, 46.25),
            (21, 'National', 'Advanced', 21.50, 32.25, 43.00, 53.75),
            (23, 'London', 'Standard', 23.50, 35.25, 47.00, 58.75),
            (23, 'London', 'Advanced', 27.00, 40.50, 54.00, 67.50),
            (23, 'South East', 'Standard', 21.00, 31.50, 42.00, 52.50),
            (23, 'South East', 'Advanced', 24.00, 36.00, 48.00, 60.00),
            (23, 'National', 'Standard', 20.00, 30.00, 40.00, 50.00),
            (23, 'National', 'Advanced', 23.00, 34.50, 46.00, 57.50),
            (27, 'London', 'Standard', 25.00, 37.50, 50.00, 62.50),
            (27, 'London', 'Advanced', 29.00, 43.50, 58.00, 72.50),
            (27, 'South East', 'Standard', 22.50, 33.75, 45.00, 56.25),
            (27, 'South East', 'Advanced', 26.00, 39.00, 52.00, 65.00),
            (27, 'National', 'Standard', 21.00, 31.50, 42.00, 52.50),
            (27, 'National', 'Advanced', 24.50, 36.75, 49.00, 61.25),
            (30, 'London', 'Standard', 30.50, 45.75, 61.00, 76.25),
            (30, 'London', 'Advanced', 35.00, 52.50, 70.00, 87.50),
            (30, 'South East', 'Standard', 28.00, 42.00, 56.00, 70.00),
            (30, 'South East', 'Advanced', 32.00, 48.00, 64.00, 80.00),
            (30, 'National', 'Standard', 26.00, 39.00, 52.00, 65.00),
            (30, 'National', 'Advanced', 30.00, 45.00, 60.00, 75.00),
            (33, 'London', 'Standard', 32.50, 48.75, 65.00, 81.25),
            (33, 'London', 'Advanced', 38.00, 57.00, 76.00, 95.00),
            (33, 'South East', 'Standard', 30.00, 45.00, 60.00, 75.00),
            (33, 'South East', 'Advanced', 35.00, 52.50, 70.00, 87.50),
            (33, 'National', 'Standard', 27.50, 41.25, 55.00, 68.75),
            (33, 'National', 'Advanced', 32.00, 48.00, 64.00, 80.00),
            (36, 'London', 'Standard', 26.00, 39.00, 52.00, 65.00),
            (36, 'London', 'Advanced', 30.00, 45.00, 60.00, 75.00),
            (36, 'South East', 'Standard', 22.50, 33.75, 45.00, 56.25),
            (36, 'South East', 'Advanced', 26.00, 39.00, 52.00, 65.00),
            (36, 'National', 'Standard', 22.50, 33.75, 45.00, 56.25),
            (36, 'National', 'Advanced', 26.00, 39.00, 52.00, 65.00),
            (39, 'London', 'Standard', 27.00, 40.50, 54.00, 67.50),
            (39, 'London', 'Advanced', 31.00, 46.50, 62.00, 77.50),
            (39, 'South East', 'Standard', 23.00, 34.50, 46.00, 57.50),
            (39, 'South East', 'Advanced', 27.00, 40.50, 54.00, 67.50),
            (39, 'National', 'Standard', 23.00, 34.50, 46.00, 57.50),
            (39, 'National', 'Advanced', 27.00, 40.50, 54.00, 67.50),
            (44, 'London', 'Standard', 24.00, 36.00, 48.00, 60.00),
            (44, 'London', 'Advanced', 28.00, 42.00, 56.00, 70.00),
            (44, 'South East', 'Standard', 21.00, 31.50, 42.00, 52.50),
            (44, 'South East', 'Advanced', 25.00, 37.50, 50.00, 62.50),
            (44, 'National', 'Standard', 21.00, 31.50, 42.00, 52.50),
            (44, 'National', 'Advanced', 25.00, 37.50, 50.00, 62.50),
            (45, 'London', 'Standard', 22.00, 33.00, 44.00, 55.00),
            (45, 'London', 'Advanced', 26.00, 39.00, 52.00, 65.00),
            (45, 'South East', 'Standard', 19.00, 28.50, 38.00, 47.50),
            (45, 'South East', 'Advanced', 23.00, 34.50, 46.00, 57.50),
            (45, 'National', 'Standard', 19.00, 28.50, 38.00, 47.50),
            (45, 'National', 'Advanced', 23.00, 34.50, 46.00, 57.50),
            (48, 'London', 'Standard', 25.00, 37.50, 50.00, 62.50),
            (48, 'London', 'Advanced', 28.00, 42.00, 56.00, 70.00),
            (48, 'South East', 'Standard', 21.00, 31.50, 42.00, 52.50),
            (48, 'South East', 'Advanced', 24.00, 36.00, 48.00, 60.00),
            (48, 'National', 'Standard', 21.00, 31.50, 42.00, 52.50),
            (48, 'National', 'Advanced', 24.00, 36.00, 48.00, 60.00),
            (51, 'London', 'Standard', 25.00, 37.50, 50.00, 62.50),
            (51, 'London', 'Advanced', 28.00, 42.00, 56.00, 70.00),
            (51, 'South East', 'Standard', 21.00, 31.50, 42.00, 52.50),
            (51, 'South East', 'Advanced', 24.00, 36.00, 48.00, 60.00),
            (51, 'National', 'Standard', 21.00, 31.50, 42.00, 52.50),
            (51, 'National', 'Advanced', 24.00, 36.00, 48.00, 60.00),
            (61, 'London', 'Standard', 18.00, 27.00, 36.00, 45.00),
            (61, 'London', 'Advanced', 22.00, 33.00, 44.00, 55.00),
            (61, 'South East', 'Standard', 15.00, 22.50, 30.00, 37.50),
            (61, 'South East', 'Advanced', 19.00, 28.50, 38.00, 47.50),
            (61, 'National', 'Standard', 15.00, 22.50, 30.00, 37.50),
            (61, 'National', 'Advanced', 19.00, 28.50, 38.00, 47.50),
            (67, 'London', 'Standard', 45.00, 67.50, 90.00, 112.50),
            (67, 'London', 'Advanced', 85.00, 127.50, 170.00, 212.50),
            (67, 'South East', 'Standard', 40.00, 60.00, 80.00, 100.00),
            (67, 'South East', 'Advanced', 75.00, 112.50, 150.00, 187.50),
            (67, 'National', 'Standard', 38.00, 57.00, 76.00, 95.00),
            (67, 'National', 'Advanced', 70.00, 105.00, 140.00, 175.00);
        )";
        
        // Insert equipment
        const char* equipmentData = R"(
            INSERT OR IGNORE INTO equipment (name, description, category, daily_rate, weekly_rate, monthly_rate, operator_cost, fuel_cost, maintenance_cost) VALUES
            ('Mini Excavator', '1.5 tonne mini excavator', 'Plant', 120.00, 600.00, 2000.00, 20.00, 15.00, 5.00),
            ('Dump Truck', '3 tonne dump truck', 'Plant', 100.00, 500.00, 1800.00, 25.00, 20.00, 7.00),
            ('Concrete Mixer', 'Electric concrete mixer', 'Tools', 30.00, 150.00, 500.00, 0.00, 5.00, 2.00),
            ('Scaffold Tower', '3m mobile scaffold tower', 'Access', 40.00, 200.00, 700.00, 0.00, 0.00, 3.00),
            ('Cement Mixer', '5 cu ft petrol cement mixer', 'Tools', 35.00, 175.00, 600.00, 0.00, 10.00, 3.00),
            ('Power Tools Set', 'Drill, saw, sander set', 'Tools', 25.00, 125.00, 400.00, 0.00, 0.00, 2.00),
            ('Site Toilet', 'Portable site toilet', 'Welfare', 15.00, 75.00, 250.00, 0.00, 0.00, 5.00),
            ('Generator', '3kVA diesel generator', 'Power', 40.00, 200.00, 700.00, 0.00, 15.00, 5.00),
            ('Forklift', '2.5 tonne telehandler', 'Plant', 150.00, 750.00, 2500.00, 30.00, 25.00, 10.00),
            ('Compressor', '100L air compressor', 'Tools', 35.00, 175.00, 600.00, 0.00, 10.00, 4.00);
        )";
        
        executeQuery(materialCategoriesData);
        executeQuery(materialsData);
        executeQuery(tradeCategoriesData);
        executeQuery(laborRatesData);
        executeQuery(equipmentData);
    }
};

// Material Database with Live Pricing
class MaterialDatabase {
private:
    DatabaseManager* db;
    
public:
    MaterialDatabase(DatabaseManager* database) : db(database) {}
    
    vector<map<string, string>> findMaterials(const string& query, 
                                             const string& category = "",
                                             bool comparePrices = true) {
        string sql = "SELECT m.*, mc.name as category_name FROM materials m ";
        sql += "JOIN material_categories mc ON m.category_id = mc.id ";
        sql += "WHERE m.name LIKE ? OR m.description LIKE ?";
        vector<string> params = {"%" + query + "%", "%" + query + "%"};
        
        if (!category.empty()) {
            sql += " AND mc.name = ?";
            params.push_back(category);
        }
        
        return db->executeSelectQuery(sql, params);
    }
    
    vector<map<string, string>> getMaterialsByCategory(int categoryId) {
        string sql = "SELECT * FROM materials WHERE category_id = ?";
        vector<string> params = {to_string(categoryId)};
        return db->executeSelectQuery(sql, params);
    }
    
    vector<map<string, string>> getMaterialCategories(int parentId = 0) {
        string sql = "SELECT * FROM material_categories WHERE parent_id ";
        vector<string> params;
        
        if (parentId == 0) {
            sql += "IS NULL";
        } else {
            sql += "= ?";
            params.push_back(to_string(parentId));
        }
        
        return db->executeSelectQuery(sql, params);
    }
    
    double calculateMaterialCost(int materialId, double quantity, 
                                bool includeVAT = true) {
        string sql = "SELECT base_price, vat_rate FROM materials WHERE id = ?";
        vector<string> params = {to_string(materialId)};
        
        auto results = db->executeSelectQuery(sql, params);
        if (results.empty()) return 0.0;
        
        double basePrice = stod(results[0]["base_price"]);
        double vatRate = stod(results[0]["vat_rate"]);
        double total = basePrice * quantity;
        
        if (includeVAT) {
            total *= (1 + vatRate);
        }
        
        return total;
    }
    
    json generateProcurementList(int projectId) {
        string sql = R"(
            SELECT m.name, mc.name as category, m.unit, pm.quantity, m.base_price, 
                   (pm.quantity * m.base_price) as total, m.supplier, pm.status, pm.delivery_date
            FROM project_materials pm
            JOIN materials m ON pm.material_id = m.id
            JOIN material_categories mc ON m.category_id = mc.id
            WHERE pm.project_id = ?
            ORDER BY mc.name, m.name
        )";
        
        vector<string> params = {to_string(projectId)};
        auto results = db->executeSelectQuery(sql, params);
        
        json procurementList = json::array();
        for (const auto& row : results) {
            procurementList.push_back({
                {"name", row["name"]},
                {"category", row["category"]},
                {"unit", row["unit"]},
                {"quantity", row["quantity"]},
                {"unit_price", row["base_price"]},
                {"total", row["total"]},
                {"supplier", row["supplier"]},
                {"status", row["status"]},
                {"delivery_date", row["delivery_date"]}
            });
        }
        
        return procurementList;
    }
};

// Labor Cost Calculator
class LaborCalculator {
private:
    DatabaseManager* db;
    
public:
    LaborCalculator(DatabaseManager* database) : db(database) {}
    
    vector<map<string, string>> getTradeCategories(int parentId = 0) {
        string sql = "SELECT * FROM trade_categories WHERE parent_id ";
        vector<string> params;
        
        if (parentId == 0) {
            sql += "IS NULL";
        } else {
            sql += "= ?";
            params.push_back(to_string(parentId));
        }
        
        return db->executeSelectQuery(sql, params);
    }
    
    double calculateLaborCost(int tradeId, const string& region, 
                             const string& level, double hours) {
        string sql = "SELECT rate FROM labor_rates WHERE trade_id = ? AND region = ? AND level = ?";
        vector<string> params = {to_string(tradeId), region, level};
        
        auto results = db->executeSelectQuery(sql, params);
        if (results.empty()) return 0.0;
        
        double rate = stod(results[0]["rate"]);
        return rate * hours;
    }
    
    double calculateProjectLaborCost(int projectId) {
        string sql = R"(
            SELECT trade_id, hours, rate, level 
            FROM project_labor 
            WHERE project_id = ?
        )";
        
        vector<string> params = {to_string(projectId)};
        auto results = db->executeSelectQuery(sql, params);
        
        double total = 0.0;
        for (const auto& row : results) {
            total += stod(row["hours"]) * stod(row["rate"]);
        }
        
        return total;
    }
    
    json getLaborRates(int tradeId = 0) {
        string sql = R"(
            SELECT lr.*, tc.name as trade_name 
            FROM labor_rates lr
            JOIN trade_categories tc ON lr.trade_id = tc.id
        )";
        vector<string> params;
        
        if (tradeId > 0) {
            sql += " WHERE lr.trade_id = ?";
            params.push_back(to_string(tradeId));
        }
        
        sql += " ORDER BY tc.name, lr.region, lr.level";
        
        auto results = db->executeSelectQuery(sql, params);
        
        json laborRates = json::array();
        for (const auto& row : results) {
            laborRates.push_back({
                {"trade_id", row["trade_id"]},
                {"trade_name", row["trade_name"]},
                {"region", row["region"]},
                {"level", row["level"]},
                {"rate", row["rate"]},
                {"overtime_rate", row["overtime_rate"]},
                {"weekend_rate", row["weekend_rate"]},
                {"holiday_rate", row["holiday_rate"]}
            });
        }
        
        return laborRates;
    }
};

// Equipment Manager
class EquipmentManager {
private:
    DatabaseManager* db;
    
public:
    EquipmentManager(DatabaseManager* database) : db(database) {}
    
    vector<map<string, string>> getEquipment() {
        string sql = "SELECT * FROM equipment ORDER BY name";
        return db->executeSelectQuery(sql);
    }
    
    double calculateEquipmentCost(int equipmentId, int days) {
        string sql = "SELECT daily_rate FROM equipment WHERE id = ?";
        vector<string> params = {to_string(equipmentId)};
        
        auto results = db->executeSelectQuery(sql, params);
        if (results.empty()) return 0.0;
        
        double dailyRate = stod(results[0]["daily_rate"]);
        return dailyRate * days;
    }
    
    double calculateProjectEquipmentCost(int projectId) {
        string sql = R"(
            SELECT equipment_id, days, daily_rate 
            FROM project_equipment 
            WHERE project_id = ?
        )";
        
        vector<string> params = {to_string(projectId)};
        auto results = db->executeSelectQuery(sql, params);
        
        double total = 0.0;
        for (const auto& row : results) {
            total += stod(row["days"]) * stod(row["daily_rate"]);
        }
        
        return total;
    }
};

// AI Assistant with Enhanced Capabilities
class AIAssistant {
private:
    DatabaseManager* db;
    map<string, vector<string>> knowledgeBase;
    
public:
    AIAssistant(DatabaseManager* database) : db(database) {
        initializeKnowledgeBase();
    }
    
    void initializeKnowledgeBase() {
        knowledgeBase["regulations"] = {
            "Part A: Structure (2025 Edition)", 
            "Part B: Fire Safety (2025 Edition)",
            "Part L: Conservation of Fuel and Power (2025 Edition)",
            "Part P: Electrical Safety (2025 Edition)",
            "Building Regulations 2025 Updates",
            "Planning Permission Guidelines 2025",
            "CDM Regulations 2025",
            "Health and Safety at Work Act 2025"
        };
        
        knowledgeBase["safety"] = {
            "CDM Regulations 2025", 
            "Risk Assessment Protocols",
            "Site Safety Management",
            "HSE Guidance Notes 2025",
            "COVID-19 Site Protocols",
            "Working at Height Regulations",
            "Manual Handling Guidelines",
            "PPE Requirements 2025"
        };
        
        knowledgeBase["materials"] = {
            "BRE Material Specifications",
            "NHBC Standards 2025",
            "Sustainable Building Materials",
            "Material Safety Data Sheets",
            "UKCA Marking Requirements",
            "CE Marking Transition",
            "Environmental Product Declarations",
            "Recycled Content Requirements"
        };
        
        knowledgeBase["costs"] = {
            "BCIS Cost Models 2025",
            "SPONS Price Book 2025",
            "Material Price Inflation Trends",
            "Labor Rate Surveys 2025",
            "Equipment Hire Rates 2025",
            "Regional Cost Variations",
            "VAT Regulations for Construction",
            "CIS Tax Calculations"
        };
        
        knowledgeBase["best_practices"] = {
            "Brickwork Best Practices",
            "Concrete Pouring Techniques",
            "Roof Installation Guidelines",
            "Electrical Installation Standards",
            "Plumbing System Design",
            "Insulation Installation Methods",
            "Plastering Techniques",
            "Painting and Decorating Standards"
        };
    }
    
    string provideGuidance(const string& query, const string& context = "") {
        // First check local knowledge base
        for (const auto& category : knowledgeBase) {
            for (const auto& topic : category.second) {
                if (query.find(topic) != string::npos) {
                    return generateLocalResponse(query, category.first, context);
                }
            }
        }
        
        // If not found locally, provide generic advice
        return generateGenericResponse(query, context);
    }
    
    string generateLocalResponse(const string& query, const string& category, const string& context) {
        if (category == "regulations") {
            return "Based on UK Building Regulations 2025, I recommend consulting " +
                   knowledgeBase["regulations"][0] + " for structural considerations. " +
                   "For specific " + query + ", you may need to review section 4.2 of the approved documents. " +
                   (context.empty() ? "" : "In the context of " + context + ", ") +
                   "the 2025 updates include new requirements for energy efficiency and fire safety.";
        } else if (category == "safety") {
            return "For " + query + ", the current CDM 2025 regulations require a full risk assessment. " +
                   "Key considerations include: 1. Site security 2. Worker training 3. Emergency procedures. " +
                   (context.empty() ? "" : "For your " + context + ", ") +
                   "I recommend implementing a site-specific safety plan with daily briefings.";
        } else if (category == "materials") {
            return "Regarding " + query + ", the 2025 standards specify requirements for material durability and sustainability. " +
                   "You should ensure all materials have UKCA marking and comply with the latest BRE guidelines. " +
                   (context.empty() ? "" : "For your " + context + ", ") +
                   "I recommend selecting materials with high recycled content and environmental certifications.";
        } else if (category == "costs") {
            return "For accurate cost estimation of " + query + ", I recommend using our built-in material and labor calculators. " +
                   "Based on current market data, typical costs for similar items range from £X to £Y depending on specifications. " +
                   (context.empty() ? "" : "For your " + context + ", ") +
                   "I've identified potential cost savings of approximately Z% through value engineering options.";
        } else if (category == "best_practices") {
            return "For " + query + ", industry best practices recommend following the guidelines published by the relevant trade association. " +
                   "Key considerations include: 1. Proper preparation 2. Quality materials 3. Skilled workmanship. " +
                   (context.empty() ? "" : "For your " + context + ", ") +
                   "I recommend consulting with a specialist to ensure compliance with all technical standards.";
        }
        
        return "I found relevant information in our " + category + " database. " +
               "For " + query + ", the current guidelines recommend..." +
               (context.empty() ? "" : " In the context of " + context + ", ");
    }
    
    string generateGenericResponse(const string& query, const string& context) {
        if (query.find("cost") != string::npos || query.find("price") != string::npos) {
            return "For accurate cost estimation, I recommend using our built-in material and labor calculators. " +
                   (context.empty() ? "" : "Based on " + context + ", ") +
                   "typical costs for similar projects range from £50-200 per square meter depending on specifications.";
        } else if (query.find("time") != string::npos || query.find("schedule") != string::npos) {
            return "Project timelines vary based on scope, weather conditions, and material availability. " +
                   "A typical residential extension takes 12-20 weeks from planning to completion. " +
                   (context.empty() ? "" : "For your " + context + ", ") +
                   "I recommend creating a detailed project schedule with contingency for unexpected delays.";
        } else if (query.find("VAT") != string::npos || query.find("tax") != string::npos) {
            return "The current VAT rate for construction services is 20%. Some services may qualify for reduced rates. " +
                   "The VAT reverse charge mechanism applies to most construction services. " +
                   (context.empty() ? "" : "For your " + context + ", ") +
                   "I recommend consulting with a tax professional for your specific situation.";
        } else if (query.find("regulation") != string::npos || query.find("compliance") != string::npos) {
            return "UK construction is governed by the Building Regulations 2025 and various other statutory instruments. " +
                   "Key areas include structural integrity, fire safety, energy efficiency, and accessibility. " +
                   (context.empty() ? "" : "For your " + context + ", ") +
                   "I recommend reviewing the approved documents relevant to your project type.";
        } else if (query.find("material") != string::npos || query.find("product") != string::npos) {
            return "Material selection should consider performance, durability, sustainability, and cost. " +
                   "All materials used in UK construction must carry appropriate certification (UKCA marking). " +
                   (context.empty() ? "" : "For your " + context + ", ") +
                   "I recommend using our material database to compare options from different suppliers.";
        }
        
        return "I understand you're asking about: " + query + 
               (context.empty() ? "" : " in the context of " + context) +
               ". For the most accurate information, I recommend consulting the relevant UK building regulations " +
               "or speaking with one of our certified construction advisors.";
    }
    
    string analyzeProjectPlan(int projectId) {
        // Get project details
        string sql = "SELECT * FROM projects WHERE id = ?";
        vector<string> params = {to_string(projectId)};
        auto projectResults = db->executeSelectQuery(sql, params);
        
        if (projectResults.empty()) {
            return "Project not found.";
        }
        
        string projectName = projectResults[0]["name"];
        string projectStatus = projectResults[0]["status"];
        
        // Get materials
        sql = "SELECT COUNT(*) as count, SUM(quantity * unit_price) as total FROM project_materials WHERE project_id = ?";
        auto materialResults = db->executeSelectQuery(sql, params);
        int materialCount = materialResults.empty() ? 0 : stoi(materialResults[0]["count"]);
        double materialTotal = materialResults.empty() ? 0.0 : stod(materialResults[0]["total"]);
        
        // Get labor
        sql = "SELECT COUNT(*) as count, SUM(hours * rate) as total FROM project_labor WHERE project_id = ?";
        auto laborResults = db->executeSelectQuery(sql, params);
        int laborCount = laborResults.empty() ? 0 : stoi(laborResults[0]["count"]);
        double laborTotal = laborResults.empty() ? 0.0 : stod(laborResults[0]["total"]);
        
        // Get equipment
        sql = "SELECT COUNT(*) as count, SUM(days * daily_rate) as total FROM project_equipment WHERE project_id = ?";
        auto equipmentResults = db->executeSelectQuery(sql, params);
        int equipmentCount = equipmentResults.empty() ? 0 : stoi(equipmentResults[0]["count"]);
        double equipmentTotal = equipmentResults.empty() ? 0.0 : stod(equipmentResults[0]["total"]);
        
        // Calculate total cost
        double totalCost = materialTotal + laborTotal + equipmentTotal;
        double vatAmount = totalCost * UK_VAT_RATE;
        double grandTotal = totalCost + vatAmount;
        
        // Get project budget
        double budget = stod(projectResults[0]["budget"]);
        double budgetVariance = budget - grandTotal;
        string budgetStatus = budgetVariance >= 0 ? "within budget" : "over budget";
        
        stringstream analysis;
        analysis << "AI analysis complete for project: " << projectName << "\n";
        analysis << "Project Status: " << projectStatus << "\n";
        analysis << "Materials: " << materialCount << " items, £" << fixed << setprecision(2) << materialTotal << "\n";
        analysis << "Labor: " << laborCount << " items, £" << laborTotal << "\n";
        analysis << "Equipment: " << equipmentCount << " items, £" << equipmentTotal << "\n";
        analysis << "Subtotal: £" << totalCost << "\n";
        analysis << "VAT (20%): £" << vatAmount << "\n";
        analysis << "Total: £" << grandTotal << "\n";
        analysis << "Budget: £" << budget << " (" << budgetStatus << " by £" << fabs(budgetVariance) << ")\n\n";
        
        analysis << "Recommendations:\n";
        analysis << "1. Review material specifications to ensure compliance with 2025 standards\n";
        analysis << "2. Confirm labor rates are current for your region\n";
        analysis << "3. Check lead times for critical materials to avoid delays\n";
        analysis << "4. Consider value engineering options if over budget\n";
        analysis << "5. Ensure all trades have appropriate certifications and insurance\n";
        
        // Save recommendations to database
        saveRecommendations(projectId, analysis.str());
        
        return analysis.str();
    }
    
    void saveRecommendations(int projectId, const string& recommendations) {
        vector<string> recLines;
        istringstream stream(recommendations);
        string line;
        
        while (getline(stream, line)) {
            if (line.find("Recommendations:") != string::npos) continue;
            if (!line.empty() && line.find("AI analysis") == string::npos) {
                recLines.push_back(line);
            }
        }
        
        for (const auto& rec : recLines) {
            if (!rec.empty() && rec != "\n") {
                string sql = "INSERT INTO ai_recommendations (project_id, category, recommendation, priority) VALUES (?, ?, ?, ?)";
                vector<string> params = {
                    to_string(projectId),
                    "Project Analysis",
                    rec,
                    "medium"
                };
                
                db->executeParamQuery(sql, params);
            }
        }
    }
    
    vector<map<string, string>> getRecommendations(int projectId) {
        string sql = "SELECT * FROM ai_recommendations WHERE project_id = ? ORDER BY created_at DESC";
        vector<string> params = {to_string(projectId)};
        return db->executeSelectQuery(sql, params);
    }
};

// Project Management System
class ProjectManager {
private:
    DatabaseManager* db;
    MaterialDatabase* materialDB;
    LaborCalculator* laborCalc;
    EquipmentManager* equipmentMgr;
    AIAssistant* aiAssistant;
    
public:
    ProjectManager(DatabaseManager* database, MaterialDatabase* mDB, 
                  LaborCalculator* lCalc, EquipmentManager* eMgr, AIAssistant* ai) 
        : db(database), materialDB(mDB), laborCalc(lCalc), equipmentMgr(eMgr), aiAssistant(ai) {}
    
    int createProject(int userId, const string& name, const string& description, 
                     const string& clientName, const string& clientAddress,
                     const string& clientEmail, const string& clientPhone,
                     const string& siteAddress, const string& startDate, 
                     const string& endDate, double budget) {
        string sql = R"(
            INSERT INTO projects (uuid, user_id, name, description, client_name, client_address, 
                                client_email, client_phone, site_address, start_date, end_date, budget)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        )";
        
        string uuid = generateUUID();
        vector<string> params = {
            uuid, to_string(userId), name, description, clientName, clientAddress,
            clientEmail, clientPhone, siteAddress, startDate, endDate, to_string(budget)
        };
        
        if (db->executeParamQuery(sql, params)) {
            // Get the last inserted ID
            auto results = db->executeSelectQuery("SELECT last_insert_rowid() as id");
            if (!results.empty()) {
                return stoi(results[0]["id"]);
            }
        }
        
        return -1;
    }
    
    bool addMaterialToProject(int projectId, int materialId, double quantity, 
                             double unitPrice, bool vatIncluded = true,
                             const string& stage = "planning", const string& status = "pending",
                             const string& deliveryDate = "") {
        string sql = R"(
            INSERT INTO project_materials (project_id, material_id, quantity, unit_price, vat_included, stage, status, delivery_date)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        )";
        
        vector<string> params = {
            to_string(projectId), to_string(materialId), to_string(quantity),
            to_string(unitPrice), vatIncluded ? "1" : "0", stage, status, deliveryDate
        };
        
        return db->executeParamQuery(sql, params);
    }
    
    bool addLaborToProject(int projectId, int tradeId, double hours, 
                          double rate, const string& level = "Standard",
                          const string& workerName = "", const string& workerId = "",
                          const string& stage = "planning", const string& status = "pending",
                          const string& startDate = "", const string& endDate = "") {
        string sql = R"(
            INSERT INTO project_labor (project_id, trade_id, hours, rate, level, worker_name, worker_id, stage, status, start_date, end_date)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        )";
        
        vector<string> params = {
            to_string(projectId), to_string(tradeId), to_string(hours), to_string(rate), level,
            workerName, workerId, stage, status, startDate, endDate
        };
        
        return db->executeParamQuery(sql, params);
    }
    
    bool addEquipmentToProject(int projectId, int equipmentId, int quantity, int days,
                              double dailyRate, double operatorCost = 0, double fuelCost = 0,
                              const string& stage = "planning", const string& status = "pending",
                              const string& startDate = "", const string& endDate = "") {
        string sql = R"(
            INSERT INTO project_equipment (project_id, equipment_id, quantity, days, daily_rate, operator_cost, fuel_cost, stage, status, start_date, end_date)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        )";
        
        vector<string> params = {
            to_string(projectId), to_string(equipmentId), to_string(quantity), to_string(days),
            to_string(dailyRate), to_string(operatorCost), to_string(fuelCost), stage, status,
            startDate, endDate
        };
        
        return db->executeParamQuery(sql, params);
    }
    
    bool addProjectStage(int projectId, const string& name, const string& description,
                        int sequence, const string& plannedStart, const string& plannedEnd,
                        const string& status = "pending", int progress = 0) {
        string sql = R"(
            INSERT INTO project_stages (project_id, name, description, sequence, planned_start, planned_end, status, progress)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        )";
        
        vector<string> params = {
            to_string(projectId), name, description, to_string(sequence),
            plannedStart, plannedEnd, status, to_string(progress)
        };
        
        return db->executeParamQuery(sql, params);
    }
    
    bool updateProjectStage(int stageId, const string& actualStart = "", 
                           const string& actualEnd = "", const string& status = "",
                           int progress = -1) {
        string sql = "UPDATE project_stages SET ";
        vector<string> params;
        vector<string> updates;
        
        if (!actualStart.empty()) {
            updates.push_back("actual_start = ?");
            params.push_back(actualStart);
        }
        
        if (!actualEnd.empty()) {
            updates.push_back("actual_end = ?");
            params.push_back(actualEnd);
        }
        
        if (!status.empty()) {
            updates.push_back("status = ?");
            params.push_back(status);
        }
        
        if (progress >= 0) {
            updates.push_back("progress = ?");
            params.push_back(to_string(progress));
        }
        
        if (updates.empty()) {
            return false;
        }
        
        sql += join(updates, ", ");
        sql += " WHERE id = ?";
        params.push_back(to_string(stageId));
        
        return db->executeParamQuery(sql, params);
    }
    
    bool addProjectTask(int projectId, int stageId, const string& name, const string& description,
                       int assignedTo = 0, const string& priority = "medium",
                       const string& plannedStart = "", const string& plannedEnd = "",
                       const string& status = "pending", int progress = 0) {
        string sql = R"(
            INSERT INTO project_tasks (project_id, stage_id, name, description, assigned_to, priority, planned_start, planned_end, status, progress)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        )";
        
        vector<string> params = {
            to_string(projectId), to_string(stageId), name, description,
            to_string(assignedTo), priority, plannedStart, plannedEnd, status, to_string(progress)
        };
        
        return db->executeParamQuery(sql, params);
    }
    
    bool updateProjectTask(int taskId, const string& actualStart = "", 
                          const string& actualEnd = "", const string& status = "",
                          int progress = -1, int assignedTo = -1) {
        string sql = "UPDATE project_tasks SET ";
        vector<string> params;
        vector<string> updates;
        
        if (!actualStart.empty()) {
            updates.push_back("actual_start = ?");
            params.push_back(actualStart);
        }
        
        if (!actualEnd.empty()) {
            updates.push_back("actual_end = ?");
            params.push_back(actualEnd);
        }
        
        if (!status.empty()) {
            updates.push_back("status = ?");
            params.push_back(status);
        }
        
        if (progress >= 0) {
            updates.push_back("progress = ?");
            params.push_back(to_string(progress));
        }
        
        if (assignedTo >= 0) {
            updates.push_back("assigned_to = ?");
            params.push_back(to_string(assignedTo));
        }
        
        if (updates.empty()) {
            return false;
        }
        
        sql += join(updates, ", ");
        sql += " WHERE id = ?";
        params.push_back(to_string(taskId));
        
        return db->executeParamQuery(sql, params);
    }
    
    bool updateProjectProgress(int projectId, int progress) {
        string sql = "UPDATE projects SET progress = ? WHERE id = ?";
        vector<string> params = {to_string(progress), to_string(projectId)};
        return db->executeParamQuery(sql, params);
    }
    
    bool updateProjectStatus(int projectId, const string& status) {
        string sql = "UPDATE projects SET status = ? WHERE id = ?";
        vector<string> params = {status, to_string(projectId)};
        return db->executeParamQuery(sql, params);
    }
    
    json generateEstimate(int projectId, bool includeVAT = true) {
        // Calculate material costs
        string sql = R"(
            SELECT SUM(pm.quantity * pm.unit_price) as total
            FROM project_materials pm
            WHERE pm.project_id = ?
        )";
        
        vector<string> params = {to_string(projectId)};
        auto materialResults = db->executeSelectQuery(sql, params);
        double materialCost = materialResults.empty() ? 0.0 : stod(materialResults[0]["total"]);
        
        // Calculate labor costs
        double laborCost = laborCalc->calculateProjectLaborCost(projectId);
        
        // Calculate equipment costs
        double equipmentCost = equipmentMgr->calculateProjectEquipmentCost(projectId);
        
        // Get project details
        sql = "SELECT budget FROM projects WHERE id = ?";
        auto projectResults = db->executeSelectQuery(sql, params);
        double budget = projectResults.empty() ? 0.0 : stod(projectResults[0]["budget"]);
        
        // Calculate totals
        double subtotal = materialCost + laborCost + equipmentCost;
        double vatAmount = includeVAT ? subtotal * UK_VAT_RATE : 0.0;
        double total = subtotal + vatAmount;
        double remainingBudget = budget - total;
        
        json estimate = {
            {"project_id", projectId},
            {"material_cost", materialCost},
            {"labor_cost", laborCost},
            {"equipment_cost", equipmentCost},
            {"subtotal", subtotal},
            {"vat_rate", UK_VAT_RATE},
            {"vat_amount", vatAmount},
            {"total", total},
            {"budget", budget},
            {"remaining_budget", remainingBudget},
            {"budget_status", remainingBudget >= 0 ? "within_budget" : "over_budget"}
        };
        
        return estimate;
    }
    
    json generateInvoice(int projectId, const string& invoiceNumber, 
                        const string& issueDate, const string& dueDate,
                        const string& notes = "") {
        auto estimate = generateEstimate(projectId, true);
        
        string sql = R"(
            INSERT INTO invoices (uuid, project_id, invoice_number, issue_date, due_date, total_amount, vat_amount, notes)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        )";
        
        string uuid = generateUUID();
        vector<string> params = {
            uuid, to_string(projectId), invoiceNumber, issueDate, dueDate,
            to_string(estimate["total"]), to_string(estimate["vat_amount"]), notes
        };
        
        if (db->executeParamQuery(sql, params)) {
            // Get the last inserted invoice ID
            auto results = db->executeSelectQuery("SELECT last_insert_rowid() as id");
            if (!results.empty()) {
                int invoiceId = stoi(results[0]["id"]);
                
                // Add invoice items for materials
                sql = R"(
                    INSERT INTO invoice_items (invoice_id, item_type, item_description, quantity, unit_price, vat_rate, total_amount)
                    SELECT ?, 'material', m.name, pm.quantity, pm.unit_price, m.vat_rate, (pm.quantity * pm.unit_price * (1 + m.vat_rate))
                    FROM project_materials pm
                    JOIN materials m ON pm.material_id = m.id
                    WHERE pm.project_id = ?
                )";
                
                vector<string> itemParams = {to_string(invoiceId), to_string(projectId)};
                db->executeParamQuery(sql, itemParams);
                
                // Add invoice items for labor
                sql = R"(
                    INSERT INTO invoice_items (invoice_id, item_type, item_description, quantity, unit_price, vat_rate, total_amount)
                    SELECT ?, 'labor', tc.name || ' - ' || pl.level, pl.hours, pl.rate, 0.2, (pl.hours * pl.rate * 1.2)
                    FROM project_labor pl
                    JOIN trade_categories tc ON pl.trade_id = tc.id
                    WHERE pl.project_id = ?
                )";
                
                db->executeParamQuery(sql, itemParams);
                
                // Add invoice items for equipment
                sql = R"(
                    INSERT INTO invoice_items (invoice_id, item_type, item_description, quantity, unit_price, vat_rate, total_amount)
                    SELECT ?, 'equipment', e.name, pe.quantity, pe.daily_rate, 0.2, (pe.quantity * pe.days * pe.daily_rate * 1.2)
                    FROM project_equipment pe
                    JOIN equipment e ON pe.equipment_id = e.id
                    WHERE pe.project_id = ?
                )";
                
                db->executeParamQuery(sql, itemParams);
                
                estimate["invoice_id"] = invoiceId;
                estimate["invoice_number"] = invoiceNumber;
                estimate["issue_date"] = issueDate;
                estimate["due_date"] = dueDate;
                estimate["status"] = "issued";
                
                return estimate;
            }
        }
        
        return json::object();
    }
    
    bool updateInvoiceStatus(int invoiceId, const string& status, 
                            double amountPaid = 0, const string& paymentDate = "",
                            const string& paymentMethod = "") {
        string sql = "UPDATE invoices SET status = ?, amount_paid = ?, payment_date = ?, payment_method = ? WHERE id = ?";
        vector<string> params = {status, to_string(amountPaid), paymentDate, paymentMethod, to_string(invoiceId)};
        return db->executeParamQuery(sql, params);
    }
    
    string getAIRecommendations(int projectId) {
        return aiAssistant->analyzeProjectPlan(projectId);
    }
    
    vector<map<string, string>> getProjectStages(int projectId) {
        string sql = "SELECT * FROM project_stages WHERE project_id = ? ORDER BY sequence";
        vector<string> params = {to_string(projectId)};
        return db->executeSelectQuery(sql, params);
    }
    
    vector<map<string, string>> getProjectTasks(int projectId, int stageId = 0) {
        string sql = "SELECT * FROM project_tasks WHERE project_id = ?";
        vector<string> params = {to_string(projectId)};
        
        if (stageId > 0) {
            sql += " AND stage_id = ?";
            params.push_back(to_string(stageId));
        }
        
        sql += " ORDER BY planned_start";
        return db->executeSelectQuery(sql, params);
    }
    
    vector<map<string, string>> getProjectInvoices(int projectId) {
        string sql = "SELECT * FROM invoices WHERE project_id = ? ORDER BY issue_date DESC";
        vector<string> params = {to_string(projectId)};
        return db->executeSelectQuery(sql, params);
    }
    
private:
    string join(const vector<string>& elements, const string& delimiter) {
        string result;
        for (size_t i = 0; i < elements.size(); i++) {
            if (i > 0) result += delimiter;
            result += elements[i];
        }
        return result;
    }
};

// User Management System
class UserManager {
private:
    DatabaseManager* db;
    SecurityManager security;
    
public:
    UserManager(DatabaseManager* database, const string& encryptionKey) 
        : db(database), security(encryptionKey) {}
    
    int registerUser(const string& email, const string& password, const string& userType,
                    const string& firstName, const string& lastName, 
                    const string& companyName = "", const string& companyRegNumber = "",
                    const string& utrNumber = "", const string& vatNumber = "", 
                    const string& cisStatus = "", const string& bankAccountDetails = "",
                    const string& address = "", const string& phoneNumber = "") {
        
        // Check if user already exists
        string checkSql = "SELECT id FROM users WHERE email = ?";
        vector<string> checkParams = {email};
        auto existingUsers = db->executeSelectQuery(checkSql, checkParams);
        
        if (!existingUsers.empty()) {
            return -1; // User already exists
        }
        
        // Hash password
        string hashedPassword = security.hashPassword(password);
        string encryptedBankDetails = security.encryptData(bankAccountDetails);
        string uuid = generateUUID();
        
        // Insert new user
        string sql = R"(
            INSERT INTO users (uuid, email, password_hash, user_type, first_name, last_name, 
                             company_name, company_reg_number, utr_number, vat_number, 
                             cis_status, bank_account_details, address, phone_number)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        )";
        
        vector<string> params = {
            uuid, email, hashedPassword, userType, firstName, lastName, 
            companyName, companyRegNumber, utrNumber, vatNumber, 
            cisStatus, encryptedBankDetails, address, phoneNumber
        };
        
        if (db->executeParamQuery(sql, params)) {
            // Get the last inserted ID
            auto results = db->executeSelectQuery("SELECT last_insert_rowid() as id");
            if (!results.empty()) {
                return stoi(results[0]["id"]);
            }
        }
        
        return -1;
    }
    
    int authenticateUser(const string& email, const string& password) {
        string sql = "SELECT id, password_hash FROM users WHERE email = ?";
        vector<string> params = {email};
        
        auto results = db->executeSelectQuery(sql, params);
        if (results.empty()) {
            return -1; // User not found
        }
        
        string storedHash = results[0]["password_hash"];
        if (security.verifyPassword(password, storedHash)) {
            return stoi(results[0]["id"]);
        }
        
        return -1; // Invalid password
    }
    
    bool updateUserSubscription(int userId, const string& plan, const string& status, 
                               const string& expiryDate) {
        string sql = "UPDATE users SET subscription_plan = ?, subscription_status = ?, subscription_expiry = ? WHERE id = ?";
        vector<string> params = {plan, status, expiryDate, to_string(userId)};
        return db->executeParamQuery(sql, params);
    }
    
    json getUserProfile(int userId) {
        string sql = "SELECT * FROM users WHERE id = ?";
        vector<string> params = {to_string(userId)};
        
        auto results = db->executeSelectQuery(sql, params);
        if (results.empty()) {
            return json::object();
        }
        
        json profile;
        for (const auto& pair : results[0]) {
            profile[pair.first] = pair.second;
        }
        
        // Decrypt bank account details
        if (profile.find("bank_account_details") != profile.end()) {
            profile["bank_account_details"] = security.decryptData(
                profile["bank_account_details"]);
        }
        
        return profile;
    }
    
    bool updateUserProfile(int userId, const map<string, string>& updates) {
        if (updates.empty()) return false;
        
        string sql = "UPDATE users SET ";
        vector<string> params;
        vector<string> setClauses;
        
        for (const auto& update : updates) {
            if (update.first == "bank_account_details") {
                setClauses.push_back(update.first + " = ?");
                params.push_back(security.encryptData(update.second));
            } else {
                setClauses.push_back(update.first + " = ?");
                params.push_back(update.second);
            }
        }
        
        sql += join(setClauses, ", ");
        sql += " WHERE id = ?";
        params.push_back(to_string(userId));
        
        return db->executeParamQuery(sql, params);
    }
    
    vector<map<string, string>> getUserProjects(int userId) {
        string sql = "SELECT * FROM projects WHERE user_id = ? ORDER BY created_at DESC";
        vector<string> params = {to_string(userId)};
        return db->executeSelectQuery(sql, params);
    }
    
private:
    string join(const vector<string>& elements, const string& delimiter) {
        string result;
        for (size_t i = 0; i < elements.size(); i++) {
            if (i > 0) result += delimiter;
            result += elements[i];
        }
        return result;
    }
};

// Main Application Class
class BuildersApp {
private:
    DatabaseManager db;
    SecurityManager security;
    MaterialDatabase materialDB;
    LaborCalculator laborCalc;
    EquipmentManager equipmentMgr;
    AIAssistant aiAssistant;
    ProjectManager projectManager;
    UserManager userManager;
    
    int currentUserId;
    string currentUserType;
    bool isLoggedIn;
    
public:
    BuildersApp() 
        : db("builders_app.db"),
          security("very_secure_encryption_key_2025"),
          materialDB(&db),
          laborCalc(&db),
          equipmentMgr(&db),
          aiAssistant(&db),
          projectManager(&db, &materialDB, &laborCalc, &equipmentMgr, &aiAssistant),
          userManager(&db, "very_secure_encryption_key_2025"),
          currentUserId(-1),
          currentUserType(""),
          isLoggedIn(false) {
    }
    
    void run() {
        cout << "==============================================" << endl;
        cout << "    BuildersApp UK Construction Platform     " << endl;
        cout << "           Version 2025.1 - Advanced         " << endl;
        cout << "==============================================" << endl;
        
        while (true) {
            if (!isLoggedIn) {
                showLoginMenu();
            } else {
                showMainMenu();
            }
        }
    }
    
    void showLoginMenu() {
        cout << "\n=== Login / Register ===" << endl;
        cout << "1. Login" << endl;
        cout << "2. Register" << endl;
        cout << "3. Exit" << endl;
        cout << "Choose an option: ";
        
        int choice;
        cin >> choice;
        cin.ignore(); // Clear newline
        
        switch (choice) {
            case 1: login(); break;
            case 2: registerUser(); break;
            case 3: exit(0);
            default: cout << "Invalid option. Please try again." << endl;
        }
    }
    
    void showMainMenu() {
        cout << "\n=== Main Menu ===" << endl;
        cout << "1. Project Management" << endl;
        cout << "2. Material Database" << endl;
        cout << "3. Labor Calculator" << endl;
        cout << "4. Equipment Management" << endl;
        cout << "5. AI Assistant" << endl;
        cout << "6. User Profile" << endl;
        cout << "7. Reports & Invoices" << endl;
        cout << "8. Logout" << endl;
        cout << "Choose an option: ";
        
        int choice;
        cin >> choice;
        cin.ignore(); // Clear newline
        
        switch (choice) {
            case 1: projectManagementMenu(); break;
            case 2: materialDatabaseMenu(); break;
            case 3: laborCalculatorMenu(); break;
            case 4: equipmentManagementMenu(); break;
            case 5: aiAssistantMenu(); break;
            case 6: userProfileMenu(); break;
            case 7: reportsMenu(); break;
            case 8: logout(); break;
            default: cout << "Invalid option. Please try again." << endl;
        }
    }
    
    void login() {
        string email, password;
        cout << "Email: ";
        getline(cin, email);
        cout << "Password: ";
        getline(cin, password);
        
        int userId = userManager.authenticateUser(email, password);
        if (userId != -1) {
            currentUserId = userId;
            isLoggedIn = true;
            
            // Get user type
            auto profile = userManager.getUserProfile(userId);
            currentUserType = profile["user_type"];
            
            cout << "Login successful! Welcome back, " << profile["first_name"] << " " << profile["last_name"] << "." << endl;
        } else {
            cout << "Invalid email or password. Please try again." << endl;
        }
    }
    
    void registerUser() {
        string email, password, userType, firstName, lastName, companyName, companyRegNumber;
        string utrNumber, vatNumber, cisStatus, bankAccountDetails, address, phoneNumber;
        
        cout << "Email: ";
        getline(cin, email);
        cout << "Password: ";
        getline(cin, password);
        cout << "First Name: ";
        getline(cin, firstName);
        cout << "Last Name: ";
        getline(cin, lastName);
        
        cout << "User Type (homeowner/contractor/subcontractor/supplier): ";
        getline(cin, userType);
        
        if (userType == "contractor" || userType == "subcontractor" || userType == "supplier") {
            cout << "Company Name: ";
            getline(cin, companyName);
            cout << "Company Registration Number: ";
            getline(cin, companyRegNumber);
            cout << "UTR Number: ";
            getline(cin, utrNumber);
            cout << "VAT Number: ";
            getline(cin, vatNumber);
            cout << "CIS Status: ";
            getline(cin, cisStatus);
        }
        
        cout << "Bank Account Details: ";
        getline(cin, bankAccountDetails);
        cout << "Address: ";
        getline(cin, address);
        cout << "Phone Number: ";
        getline(cin, phoneNumber);
        
        int userId = userManager.registerUser(email, password, userType, firstName, lastName, 
                                            companyName, companyRegNumber, utrNumber, vatNumber,
                                            cisStatus, bankAccountDetails, address, phoneNumber);
        
        if (userId != -1) {
            cout << "Registration successful! Your user ID is: " << userId << endl;
        } else {
            cout << "Registration failed. The email might already be in use." << endl;
        }
    }
    
    void logout() {
        currentUserId = -1;
        currentUserType = "";
        isLoggedIn = false;
        cout << "Logged out successfully." << endl;
    }
    
    void projectManagementMenu() {
        cout << "\n=== Project Management ===" << endl;
        cout << "1. Create New Project" << endl;
        cout << "2. List My Projects" << endl;
        cout << "3. View Project Details" << endl;
        cout << "4. Add Materials to Project" << endl;
        cout << "5. Add Labor to Project" << endl;
        cout << "6. Add Equipment to Project" << endl;
        cout << "7. Add Project Stages" << endl;
        cout << "8. Add Project Tasks" << endl;
        cout << "9. Update Project Progress" << endl;
        cout << "10. Back to Main Menu" << endl;
        cout << "Choose an option: ";
        
        int choice;
        cin >> choice;
        cin.ignore();
        
        switch (choice) {
            case 1: createProject(); break;
            case 2: listProjects(); break;
            case 3: viewProjectDetails(); break;
            case 4: addMaterialsToProject(); break;
            case 5: addLaborToProject(); break;
            case 6: addEquipmentToProject(); break;
            case 7: addProjectStages(); break;
            case 8: addProjectTasks(); break;
            case 9: updateProjectProgress(); break;
            case 10: return;
            default: cout << "Invalid option. Please try again." << endl;
        }
    }
    
    void createProject() {
        string name, description, clientName, clientAddress, clientEmail, clientPhone;
        string siteAddress, startDate, endDate;
        double budget;
        
        cout << "Project Name: ";
        getline(cin, name);
        cout << "Description: ";
        getline(cin, description);
        cout << "Client Name: ";
        getline(cin, clientName);
        cout << "Client Address: ";
        getline(cin, clientAddress);
        cout << "Client Email: ";
        getline(cin, clientEmail);
        cout << "Client Phone: ";
        getline(cin, clientPhone);
        cout << "Site Address: ";
        getline(cin, siteAddress);
        cout << "Start Date (YYYY-MM-DD): ";
        getline(cin, startDate);
        cout << "End Date (YYYY-MM-DD): ";
        getline(cin, endDate);
        cout << "Budget: £";
        cin >> budget;
        cin.ignore();
        
        int projectId = projectManager.createProject(currentUserId, name, description, 
                                                   clientName, clientAddress, clientEmail, clientPhone,
                                                   siteAddress, startDate, endDate, budget);
        
        if (projectId != -1) {
            cout << "Project created successfully! Project ID: " << projectId << endl;
        } else {
            cout << "Failed to create project." << endl;
        }
    }
    
    void listProjects() {
        auto projects = userManager.getUserProjects(currentUserId);
        
        if (projects.empty()) {
            cout << "No projects found." << endl;
            return;
        }
        
        cout << "\nYour Projects:" << endl;
        cout << "ID\tName\tStatus\tProgress\tBudget" << endl;
        for (const auto& project : projects) {
            cout << project.at("id") << "\t" << project.at("name") << "\t" 
                 << project.at("status") << "\t" << project.at("progress") << "%\t£" 
                 << project.at("budget") << endl;
        }
    }
    
    void viewProjectDetails() {
        int projectId;
        cout << "Project ID: ";
        cin >> projectId;
        cin.ignore();
        
        // Get project details
        string sql = "SELECT * FROM projects WHERE id = ? AND user_id = ?";
        vector<string> params = {to_string(projectId), to_string(currentUserId)};
        auto results = db.executeSelectQuery(sql, params);
        
        if (results.empty()) {
            cout << "Project not found or access denied." << endl;
            return;
        }
        
        auto project = results[0];
        cout << "\n=== Project Details ===" << endl;
        cout << "Name: " << project["name"] << endl;
        cout << "Description: " << project["description"] << endl;
        cout << "Client: " << project["client_name"] << endl;
        cout << "Site Address: " << project["site_address"] << endl;
        cout << "Status: " << project["status"] << endl;
        cout << "Progress: " << project["progress"] << "%" << endl;
        cout << "Budget: £" << project["budget"] << endl;
        cout << "Start Date: " << project["start_date"] << endl;
        cout << "End Date: " << project["end_date"] << endl;
        
        // Show project estimate
        auto estimate = projectManager.generateEstimate(projectId);
        cout << "\n=== Project Estimate ===" << endl;
        cout << "Materials: £" << estimate["material_cost"] << endl;
        cout << "Labor: £" << estimate["labor_cost"] << endl;
        cout << "Equipment: £" << estimate["equipment_cost"] << endl;
        cout << "Subtotal: £" << estimate["subtotal"] << endl;
        cout << "VAT (" << (estimate["vat_rate"] * 100) << "%): £" << estimate["vat_amount"] << endl;
        cout << "Total: £" << estimate["total"] << endl;
        cout << "Budget: £" << estimate["budget"] << endl;
        cout << "Remaining: £" << estimate["remaining_budget"] << endl;
        cout << "Status: " << estimate["budget_status"] << endl;
        
        // Show project stages
        auto stages = projectManager.getProjectStages(projectId);
        if (!stages.empty()) {
            cout << "\n=== Project Stages ===" << endl;
            for (const auto& stage : stages) {
                cout << stage.at("name") << " - " << stage.at("status") << " - " 
                     << stage.at("progress") << "%" << endl;
            }
        }
    }
    
    void addMaterialsToProject() {
        int projectId, materialId;
        double quantity;
        string stage, status, deliveryDate;
        
        cout << "Project ID: ";
        cin >> projectId;
        cout << "Material ID: ";
        cin >> materialId;
        cout << "Quantity: ";
        cin >> quantity;
        cin.ignore();
        cout << "Stage (planning/construction/complete): ";
        getline(cin, stage);
        cout << "Status (pending/ordered/delivered): ";
        getline(cin, status);
        cout << "Delivery Date (YYYY-MM-DD, optional): ";
        getline(cin, deliveryDate);
        
        // Get material price
        string sql = "SELECT base_price FROM materials WHERE id = ?";
        vector<string> params = {to_string(materialId)};
        auto results = db.executeSelectQuery(sql, params);
        
        if (results.empty()) {
            cout << "Material not found." << endl;
            return;
        }
        
        double unitPrice = stod(results[0]["base_price"]);
        
        if (projectManager.addMaterialToProject(projectId, materialId, quantity, unitPrice, true, stage, status, deliveryDate)) {
            cout << "Material added to project successfully." << endl;
        } else {
            cout << "Failed to add material to project." << endl;
        }
    }
    
    void addLaborToProject() {
        int projectId, tradeId;
        double hours, rate;
        string level, workerName, workerId, stage, status, startDate, endDate;
        
        cout << "Project ID: ";
        cin >> projectId;
        cout << "Trade ID: ";
        cin >> tradeId;
        cout << "Hours: ";
        cin >> hours;
        cout << "Rate: £";
        cin >> rate;
        cin.ignore();
        cout << "Level (Standard/Advanced): ";
        getline(cin, level);
        cout << "Worker Name (optional): ";
        getline(cin, workerName);
        cout << "Worker ID (optional): ";
        getline(cin, workerId);
        cout << "Stage (planning/construction/complete): ";
        getline(cin, stage);
        cout << "Status (pending/scheduled/complete): ";
        getline(cin, status);
        cout << "Start Date (YYYY-MM-DD, optional): ";
        getline(cin, startDate);
        cout << "End Date (YYYY-MM-DD, optional): ";
        getline(cin, endDate);
        
        if (projectManager.addLaborToProject(projectId, tradeId, hours, rate, level, workerName, workerId, stage, status, startDate, endDate)) {
            cout << "Labor added to project successfully." << endl;
        } else {
            cout << "Failed to add labor to project." << endl;
        }
    }
    
    void addEquipmentToProject() {
        int projectId, equipmentId, quantity, days;
        double dailyRate, operatorCost, fuelCost;
        string stage, status, startDate, endDate;
        
        cout << "Project ID: ";
        cin >> projectId;
        cout << "Equipment ID: ";
        cin >> equipmentId;
        cout << "Quantity: ";
        cin >> quantity;
        cout << "Days: ";
        cin >> days;
        cout << "Daily Rate: £";
        cin >> dailyRate;
        cout << "Operator Cost: £";
        cin >> operatorCost;
        cout << "Fuel Cost: £";
        cin >> fuelCost;
        cin.ignore();
        cout << "Stage (planning/construction/complete): ";
        getline(cin, stage);
        cout << "Status (pending/scheduled/complete): ";
        getline(cin, status);
        cout << "Start Date (YYYY-MM-DD, optional): ";
        getline(cin, startDate);
        cout << "End Date (YYYY-MM-DD, optional): ";
        getline(cin, endDate);
        
        if (projectManager.addEquipmentToProject(projectId, equipmentId, quantity, days, dailyRate, operatorCost, fuelCost, stage, status, startDate, endDate)) {
            cout << "Equipment added to project successfully." << endl;
        } else {
            cout << "Failed to add equipment to project." << endl;
        }
    }
    
    void addProjectStages() {
        int projectId, sequence;
        string name, description, plannedStart, plannedEnd, status;
        int progress;
        
        cout << "Project ID: ";
        cin >> projectId;
        cin.ignore();
        cout << "Stage Name: ";
        getline(cin, name);
        cout << "Description: ";
        getline(cin, description);
        cout << "Sequence: ";
        cin >> sequence;
        cin.ignore();
        cout << "Planned Start (YYYY-MM-DD): ";
        getline(cin, plannedStart);
        cout << "Planned End (YYYY-MM-DD): ";
        getline(cin, plannedEnd);
        cout << "Status (pending/in progress/complete): ";
        getline(cin, status);
        cout << "Progress (0-100): ";
        cin >> progress;
        cin.ignore();
        
        if (projectManager.addProjectStage(projectId, name, description, sequence, plannedStart, plannedEnd, status, progress)) {
            cout << "Project stage added successfully." << endl;
        } else {
            cout << "Failed to add project stage." << endl;
        }
    }
    
    void addProjectTasks() {
        int projectId, stageId, assignedTo, progress;
        string name, description, priority, plannedStart, plannedEnd, status;
        
        cout << "Project ID: ";
        cin >> projectId;
        cout << "Stage ID (0 if not applicable): ";
        cin >> stageId;
        cin.ignore();
        cout << "Task Name: ";
        getline(cin, name);
        cout << "Description: ";
        getline(cin, description);
        cout << "Assigned To User ID (0 if not assigned): ";
        cin >> assignedTo;
        cin.ignore();
        cout << "Priority (low/medium/high): ";
        getline(cin, priority);
        cout << "Planned Start (YYYY-MM-DD): ";
        getline(cin, plannedStart);
        cout << "Planned End (YYYY-MM-DD): ";
        getline(cin, plannedEnd);
        cout << "Status (pending/in progress/complete): ";
        getline(cin, status);
        cout << "Progress (0-100): ";
        cin >> progress;
        cin.ignore();
        
        if (projectManager.addProjectTask(projectId, stageId, name, description, assignedTo, priority, plannedStart, plannedEnd, status, progress)) {
            cout << "Project task added successfully." << endl;
        } else {
            cout << "Failed to add project task." << endl;
        }
    }
    
    void updateProjectProgress() {
        int projectId, progress;
        string status;
        
        cout << "Project ID: ";
        cin >> projectId;
        cout << "New Progress (0-100): ";
        cin >> progress;
        cin.ignore();
        cout << "New Status (planning/active/on hold/complete): ";
        getline(cin, status);
        
        bool success1 = projectManager.updateProjectProgress(projectId, progress);
        bool success2 = projectManager.updateProjectStatus(projectId, status);
        
        if (success1 && success2) {
            cout << "Project progress updated successfully." << endl;
        } else {
            cout << "Failed to update project progress." << endl;
        }
    }
    
    void materialDatabaseMenu() {
        cout << "\n=== Material Database ===" << endl;
        cout << "1. Search Materials" << endl;
        cout << "2. Browse by Category" << endl;
        cout << "3. View Material Details" << endl;
        cout << "4. Back to Main Menu" << endl;
        cout << "Choose an option: ";
        
        int choice;
        cin >> choice;
        cin.ignore();
        
        switch (choice) {
            case 1: searchMaterials(); break;
            case 2: browseMaterialsByCategory(); break;
            case 3: viewMaterialDetails(); break;
            case 4: return;
            default: cout << "Invalid option. Please try again." << endl;
        }
    }
    
    void searchMaterials() {
        string query, category;
        cout << "Search Query: ";
        getline(cin, query);
        cout << "Category (optional): ";
        getline(cin, category);
        
        auto results = materialDB.findMaterials(query, category);
        
        if (results.empty()) {
            cout << "No materials found." << endl;
            return;
        }
        
        cout << "\nSearch Results:" << endl;
        cout << "ID\tCategory\tName\tPrice\tSupplier" << endl;
        for (const auto& row : results) {
            cout << row.at("id") << "\t" << row.at("category_name") << "\t" 
                 << row.at("name") << "\t£" << row.at("base_price") << "\t" 
                 << row.at("supplier") << endl;
        }
    }
    
    void browseMaterialsByCategory() {
        cout << "\n=== Browse Materials by Category ===" << endl;
        
        // Get top-level categories
        auto categories = materialDB.getMaterialCategories();
        
        for (int i = 0; i < categories.size(); i++) {
            cout << (i + 1) << ". " << categories[i]["name"] << endl;
        }
        
        cout << "Choose a category: ";
        int choice;
        cin >> choice;
        cin.ignore();
        
        if (choice < 1 || choice > categories.size()) {
            cout << "Invalid choice." << endl;
            return;
        }
        
        int categoryId = stoi(categories[choice - 1]["id"]);
        auto materials = materialDB.getMaterialsByCategory(categoryId);
        
        if (materials.empty()) {
            cout << "No materials found in this category." << endl;
            return;
        }
        
        cout << "\nMaterials in " << categories[choice - 1]["name"] << ":" << endl;
        cout << "ID\tName\tPrice\tSupplier" << endl;
        for (const auto& material : materials) {
            cout << material.at("id") << "\t" << material.at("name") << "\t£" 
                 << material.at("base_price") << "\t" << material.at("supplier") << endl;
        }
    }
    
    void viewMaterialDetails() {
        int materialId;
        cout << "Material ID: ";
        cin >> materialId;
        cin.ignore();
        
        string sql = "SELECT m.*, mc.name as category_name FROM materials m ";
        sql += "JOIN material_categories mc ON m.category_id = mc.id ";
        sql += "WHERE m.id = ?";
        vector<string> params = {to_string(materialId)};
        
        auto results = db.executeSelectQuery(sql, params);
        
        if (results.empty()) {
            cout << "Material not found." << endl;
            return;
        }
        
        auto material = results[0];
        cout << "\n=== Material Details ===" << endl;
        cout << "Name: " << material["name"] << endl;
        cout << "Category: " << material["category_name"] << endl;
        cout << "Description: " << material["description"] << endl;
        cout << "Unit: " << material["unit"] << endl;
        cout << "Price: £" << material["base_price"] << endl;
        cout << "VAT Rate: " << (stod(material["vat_rate"]) * 100) << "%" << endl;
        cout << "Supplier: " << material["supplier"] << endl;
        cout << "Brand: " << material["brand"] << endl;
        
        if (!material["weight_kg"].empty()) {
            cout << "Weight: " << material["weight_kg"] << " kg" << endl;
        }
        
        if (!material["dimensions"].empty()) {
            cout << "Dimensions: " << material["dimensions"] << endl;
        }
        
        if (!material["material_type"].empty()) {
            cout << "Material Type: " << material["material_type"] << endl;
        }
        
        if (!material["color"].empty()) {
            cout << "Color: " << material["color"] << endl;
        }
        
        if (!material["certification"].empty()) {
            cout << "Certification: " << material["certification"] << endl;
        }
        
        if (!material["sustainability_rating"].empty()) {
            cout << "Sustainability Rating: " << material["sustainability_rating"] << "/5" << endl;
        }
    }
    
    void laborCalculatorMenu() {
        cout << "\n=== Labor Calculator ===" << endl;
        cout << "1. Calculate Labor Cost" << endl;
        cout << "2. View Labor Rates" << endl;
        cout << "3. Browse Trades" << endl;
        cout << "4. Back to Main Menu" << endl;
        cout << "Choose an option: ";
        
        int choice;
        cin >> choice;
        cin.ignore();
        
        switch (choice) {
            case 1: calculateLaborCost(); break;
            case 2: viewLaborRates(); break;
            case 3: browseTrades(); break;
            case 4: return;
            default: cout << "Invalid option. Please try again." << endl;
        }
    }
    
    void calculateLaborCost() {
        int tradeId;
        string region, level;
        double hours;
        
        cout << "Trade ID: ";
        cin >> tradeId;
        cin.ignore();
        cout << "Region (London/South East/National): ";
        getline(cin, region);
        cout << "Level (Standard/Advanced): ";
        getline(cin, level);
        cout << "Hours: ";
        cin >> hours;
        cin.ignore();
        
        double cost = laborCalc.calculateLaborCost(tradeId, region, level, hours);
        cout << "Labor Cost: £" << fixed << setprecision(2) << cost << endl;
        
        if (hours > 8) {
            double overtimeHours = hours - 8;
            double overtimeCost = laborCalc.calculateLaborCost(tradeId, region, level, overtimeHours) * 0.5; // 50% overtime premium
            cout << "Includes £" << overtimeCost << " for " << overtimeHours << " overtime hours." << endl;
        }
    }
    
    void viewLaborRates() {
        int tradeId = 0;
        cout << "Trade ID (0 for all): ";
        cin >> tradeId;
        cin.ignore();
        
        auto laborRates = laborCalc.getLaborRates(tradeId);
        
        if (laborRates.empty()) {
            cout << "No labor rates found." << endl;
            return;
        }
        
        cout << "\nLabor Rates:" << endl;
        cout << "Trade\tRegion\tLevel\tRate\tOvertime\tWeekend\tHoliday" << endl;
        for (const auto& rate : laborRates) {
            cout << rate["trade_name"] << "\t" << rate["region"] << "\t" 
                 << rate["level"] << "\t£" << rate["rate"] << "\t£" 
                 << rate["overtime_rate"] << "\t£" << rate["weekend_rate"] 
                 << "\t£" << rate["holiday_rate"] << endl;
        }
    }
    
    void browseTrades() {
        cout << "\n=== Browse Trades ===" << endl;
        
        // Get top-level categories
        auto categories = laborCalc.getTradeCategories();
        
        for (int i = 0; i < categories.size(); i++) {
            cout << (i + 1) << ". " << categories[i]["name"] << endl;
        }
        
        cout << "Choose a trade category: ";
        int choice;
        cin >> choice;
        cin.ignore();
        
        if (choice < 1 || choice > categories.size()) {
            cout << "Invalid choice." << endl;
            return;
        }
        
        int categoryId = stoi(categories[choice - 1]["id"]);
        auto subcategories = laborCalc.getTradeCategories(categoryId);
        
        if (subcategories.empty()) {
            cout << "No subcategories found." << endl;
            return;
        }
        
        cout << "\nSubcategories of " << categories[choice - 1]["name"] << ":" << endl;
        for (int i = 0; i < subcategories.size(); i++) {
            cout << (i + 1) << ". " << subcategories[i]["name"] << endl;
        }
    }
    
    void equipmentManagementMenu() {
        cout << "\n=== Equipment Management ===" << endl;
        cout << "1. View Equipment" << endl;
        cout << "2. Calculate Equipment Cost" << endl;
        cout << "3. Back to Main Menu" << endl;
        cout << "Choose an option: ";
        
        int choice;
        cin >> choice;
        cin.ignore();
        
        switch (choice) {
            case 1: viewEquipment(); break;
            case 2: calculateEquipmentCost(); break;
            case 3: return;
            default: cout << "Invalid option. Please try again." << endl;
        }
    }
    
    void viewEquipment() {
        auto equipment = equipmentMgr.getEquipment();
        
        if (equipment.empty()) {
            cout << "No equipment found." << endl;
            return;
        }
        
        cout << "\nEquipment:" << endl;
        cout << "ID\tName\tDaily Rate\tWeekly Rate\tMonthly Rate" << endl;
        for (const auto& item : equipment) {
            cout << item.at("id") << "\t" << item.at("name") << "\t£" 
                 << item.at("daily_rate") << "\t£" << item.at("weekly_rate") 
                 << "\t£" << item.at("monthly_rate") << endl;
        }
    }
    
    void calculateEquipmentCost() {
        int equipmentId, days;
        cout << "Equipment ID: ";
        cin >> equipmentId;
        cout << "Days: ";
        cin >> days;
        cin.ignore();
        
        double cost = equipmentMgr.calculateEquipmentCost(equipmentId, days);
        cout << "Equipment Cost: £" << fixed << setprecision(2) << cost << endl;
        
        // Show weekly and monthly rates for comparison
        string sql = "SELECT weekly_rate, monthly_rate FROM equipment WHERE id = ?";
        vector<string> params = {to_string(equipmentId)};
        auto results = db.executeSelectQuery(sql, params);
        
        if (!results.empty()) {
            double weeklyRate = stod(results[0]["weekly_rate"]);
            double monthlyRate = stod(results[0]["monthly_rate"]);
            
            int weeks = ceil(days / 7.0);
            int months = ceil(days / 30.0);
            
            double weeklyCost = weeks * weeklyRate;
            double monthlyCost = months * monthlyRate;
            
            cout << "Weekly option (" << weeks << " weeks): £" << weeklyCost << endl;
            cout << "Monthly option (" << months << " months): £" << monthlyCost << endl;
        }
    }
    
    void aiAssistantMenu() {
        cout << "\n=== AI Assistant ===" << endl;
        cout << "1. Ask Question" << endl;
        cout << "2. Analyze Project" << endl;
        cout << "3. View Recommendations" << endl;
        cout << "4. Back to Main Menu" << endl;
        cout << "Choose an option: ";
        
        int choice;
        cin >> choice;
        cin.ignore();
        
        switch (choice) {
            case 1: askAIQuestion(); break;
            case 2: analyzeProjectWithAI(); break;
            case 3: viewAIRecommendations(); break;
            case 4: return;
            default: cout << "Invalid option. Please try again." << endl;
        }
    }
    
    void askAIQuestion() {
        string question, context;
        cout << "Your Question: ";
        getline(cin, question);
        cout << "Context (optional): ";
        getline(cin, context);
        
        string response = aiAssistant.provideGuidance(question, context);
        cout << "\nAI Response: " << response << endl;
    }
    
    void analyzeProjectWithAI() {
        int projectId;
        cout << "Project ID: ";
        cin >> projectId;
        cin.ignore();
        
        string analysis = projectManager.getAIRecommendations(projectId);
        cout << "\nAI Analysis: " << analysis << endl;
    }
    
    void viewAIRecommendations() {
        int projectId;
        cout << "Project ID: ";
        cin >> projectId;
        cin.ignore();
        
        auto recommendations = aiAssistant.getRecommendations(projectId);
        
        if (recommendations.empty()) {
            cout << "No recommendations found." << endl;
            return;
        }
        
        cout << "\nAI Recommendations:" << endl;
        for (const auto& rec : recommendations) {
            cout << "• " << rec.at("recommendation") << " (" << rec.at("priority") << " priority)" << endl;
        }
    }
    
    void userProfileMenu() {
        cout << "\n=== User Profile ===" << endl;
        cout << "1. View Profile" << endl;
        cout << "2. Update Profile" << endl;
        cout << "3. Back to Main Menu" << endl;
        cout << "Choose an option: ";
        
        int choice;
        cin >> choice;
        cin.ignore();
        
        switch (choice) {
            case 1: viewProfile(); break;
            case 2: updateProfile(); break;
            case 3: return;
            default: cout << "Invalid option. Please try again." << endl;
        }
    }
    
    void viewProfile() {
        auto profile = userManager.getUserProfile(currentUserId);
        
        if (profile.empty()) {
            cout << "Profile not found." << endl;
            return;
        }
        
        cout << "\n=== Your Profile ===" << endl;
        cout << "Name: " << profile["first_name"] << " " << profile["last_name"] << endl;
        cout << "Email: " << profile["email"] << endl;
        cout << "User Type: " << profile["user_type"] << endl;
        cout << "Company: " << profile["company_name"] << endl;
        cout << "Company Reg: " << profile["company_reg_number"] << endl;
        cout << "UTR Number: " << profile["utr_number"] << endl;
        cout << "VAT Number: " << profile["vat_number"] << endl;
        cout << "CIS Status: " << profile["cis_status"] << endl;
        cout << "Address: " << profile["address"] << endl;
        cout << "Phone: " << profile["phone_number"] << endl;
        cout << "Bank Details: " << profile["bank_account_details"] << endl;
        cout << "Subscription: " << profile["subscription_plan"] << " (" 
             << profile["subscription_status"] << ")" << endl;
        cout << "Subscription Expiry: " << profile["subscription_expiry"] << endl;
    }
    
    void updateProfile() {
        map<string, string> updates;
        string field, value;
        
        cout << "Enter field to update (or 'done' to finish): ";
        getline(cin, field);
        
        while (field != "done") {
            cout << "Enter new value for " << field << ": ";
            getline(cin, value);
            updates[field] = value;
            
            cout << "Enter field to update (or 'done' to finish): ";
            getline(cin, field);
        }
        
        if (updates.empty()) {
            cout << "No updates provided." << endl;
            return;
        }
        
        if (userManager.updateUserProfile(currentUserId, updates)) {
            cout << "Profile updated successfully." << endl;
        } else {
            cout << "Failed to update profile." << endl;
        }
    }
    
    void reportsMenu() {
        cout << "\n=== Reports & Invoices ===" << endl;
        cout << "1. Generate Estimate" << endl;
        cout << "2. Generate Invoice" << endl;
        cout << "3. View Project Reports" << endl;
        cout << "4. Back to Main Menu" << endl;
        cout << "Choose an option: ";
        
        int choice;
        cin >> choice;
        cin.ignore();
        
        switch (choice) {
            case 1: generateEstimate(); break;
            case 2: generateInvoice(); break;
            case 3: viewProjectReports(); break;
            case 4: return;
            default: cout << "Invalid option. Please try again." << endl;
        }
    }
    
    void generateEstimate() {
        int projectId;
        cout << "Project ID: ";
        cin >> projectId;
        cin.ignore();
        
        auto estimate = projectManager.generateEstimate(projectId);
        
        cout << "\n=== Project Estimate ===" << endl;
        cout << "Materials: £" << estimate["material_cost"] << endl;
        cout << "Labor: £" << estimate["labor_cost"] << endl;
        cout << "Equipment: £" << estimate["equipment_cost"] << endl;
        cout << "Subtotal: £" << estimate["subtotal"] << endl;
        cout << "VAT (" << (estimate["vat_rate"] * 100) << "%): £" << estimate["vat_amount"] << endl;
        cout << "Total: £" << estimate["total"] << endl;
        cout << "Budget: £" << estimate["budget"] << endl;
        cout << "Remaining: £" << estimate["remaining_budget"] << endl;
        cout << "Status: " << estimate["budget_status"] << endl;
        
        // Save to file
        ofstream file("estimate_" + to_string(projectId) + "_" + getCurrentDateTime() + ".txt");
        file << "=== Project Estimate ===" << endl;
        file << "Project ID: " << projectId << endl;
        file << "Materials: £" << estimate["material_cost"] << endl;
        file << "Labor: £" << estimate["labor_cost"] << endl;
        file << "Equipment: £" << estimate["equipment_cost"] << endl;
        file << "Subtotal: £" << estimate["subtotal"] << endl;
        file << "VAT (" << (estimate["vat_rate"] * 100) << "%): £" << estimate["vat_amount"] << endl;
        file << "Total: £" << estimate["total"] << endl;
        file << "Budget: £" << estimate["budget"] << endl;
        file << "Remaining: £" << estimate["remaining_budget"] << endl;
        file << "Status: " << estimate["budget_status"] << endl;
        file.close();
        
        cout << "Estimate saved to file." << endl;
    }
    
    void generateInvoice() {
        int projectId;
        string invoiceNumber, issueDate, dueDate, notes;
        
        cout << "Project ID: ";
        cin >> projectId;
        cin.ignore();
        cout << "Invoice Number: ";
        getline(cin, invoiceNumber);
        cout << "Issue Date (YYYY-MM-DD): ";
        getline(cin, issueDate);
        cout << "Due Date (YYYY-MM-DD): ";
        getline(cin, dueDate);
        cout << "Notes (optional): ";
        getline(cin, notes);
        
        auto invoice = projectManager.generateInvoice(projectId, invoiceNumber, issueDate, dueDate, notes);
        
        if (!invoice.empty()) {
            cout << "\n=== Invoice Generated ===" << endl;
            cout << "Invoice #: " << invoice["invoice_number"] << endl;
            cout << "Issue Date: " << invoice["issue_date"] << endl;
            cout << "Due Date: " << invoice["due_date"] << endl;
            cout << "Total: £" << invoice["total"] << endl;
            cout << "VAT: £" << invoice["vat_amount"] << endl;
            cout << "Status: " << invoice["status"] << endl;
            
            // Save to file
            ofstream file("invoice_" + string(invoice["invoice_number"]) + ".txt");
            file << "=== Invoice ===" << endl;
            file << "Invoice #: " << invoice["invoice_number"] << endl;
            file << "Issue Date: " << invoice["issue_date"] << endl;
            file << "Due Date: " << invoice["due_date"] << endl;
            file << "Total: £" << invoice["total"] << endl;
            file << "VAT: £" << invoice["vat_amount"] << endl;
            file << "Status: " << invoice["status"] << endl;
            file << "Notes: " << notes << endl;
            file.close();
            
            cout << "Invoice saved to file." << endl;
        } else {
            cout << "Failed to generate invoice." << endl;
        }
    }
    
    void viewProjectReports() {
        int projectId;
        cout << "Project ID: ";
        cin >> projectId;
        cin.ignore();
        
        auto invoices = projectManager.getProjectInvoices(projectId);
        
        if (invoices.empty()) {
            cout << "No invoices found for this project." << endl;
            return;
        }
        
        cout << "\n=== Project Invoices ===" << endl;
        cout << "Invoice #\tIssue Date\tDue Date\tTotal\tStatus" << endl;
        for (const auto& invoice : invoices) {
            cout << invoice.at("invoice_number") << "\t" << invoice.at("issue_date") << "\t" 
                 << invoice.at("due_date") << "\t£" << invoice.at("total_amount") << "\t" 
                 << invoice.at("status") << endl;
        }
    }
};

int main() {
    BuildersApp app;
    app.run();
    return 0;
}
